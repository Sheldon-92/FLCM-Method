# Story 10.2: Frontmatter Metadata Management

## Status
Approved

## Story
**As a** content creator,  
**I want** rich metadata automatically embedded in my documents,  
**so that** I can easily search, filter, and track my content across my knowledge base.

**Estimated Time:** 4-5 hours

## Acceptance Criteria
1. User can find any document within 5 seconds using metadata filters
2. Document creation and modification dates are automatically tracked and searchable
3. Content confidence and quality scores help users identify most valuable content
4. Users can trace content relationships and sources without manual effort
5. Platform-specific metadata enables seamless content adaptation
6. Metadata schema prevents data corruption and ensures consistency

## Tasks / Subtasks
- [ ] Implement YAML frontmatter generation (AC: 1)
  - [ ] Create FrontmatterGenerator class
  - [ ] Build YAML serialization system
  - [ ] Handle special characters and escaping
  - [ ] Add multiline content support
  - [ ] Implement array and object handling
  - [ ] Create formatting consistency
- [ ] Build metadata schema validation (AC: 2)
  - [ ] Create MetadataSchema definition
  - [ ] Implement schema validator
  - [ ] Add required field checking
  - [ ] Build type validation system
  - [ ] Handle validation errors gracefully
  - [ ] Create schema versioning
- [ ] Implement automatic timestamp management (AC: 3)
  - [ ] Create TimestampManager utility
  - [ ] Track document creation time
  - [ ] Update modification timestamps
  - [ ] Handle timezone considerations
  - [ ] Add timestamp formatting options
  - [ ] Implement timestamp validation
- [ ] Build confidence and understanding tracking (AC: 4)
  - [ ] Create ConfidenceTracker system
  - [ ] Implement understanding level metrics
  - [ ] Track agent confidence scores
  - [ ] Add learning progression tracking
  - [ ] Create confidence aggregation
  - [ ] Build confidence history
- [ ] Implement source and relationship linking (AC: 5)
  - [ ] Create SourceTracker system
  - [ ] Build relationship mapping
  - [ ] Add citation management
  - [ ] Implement dependency tracking
  - [ ] Create link validation
  - [ ] Add relationship types
- [ ] Add platform-specific metadata (AC: 6)
  - [ ] Define platform metadata schemas
  - [ ] Implement LinkedIn-specific fields
  - [ ] Add Twitter metadata support
  - [ ] Create platform detection
  - [ ] Build metadata inheritance
  - [ ] Add custom field support

## Dev Notes

### Frontmatter Architecture:
```typescript
interface DocumentMetadata {
  // Core identification
  id: string;
  title: string;
  type: DocumentType;
  status: DocumentStatus;
  
  // Timestamps
  created: Date;
  modified: Date;
  published?: Date;
  
  // Agent and workflow
  createdBy: AgentType;
  workflow: WorkflowType;
  phase: WorkflowPhase;
  
  // Content analysis
  confidence: ConfidenceMetrics;
  understanding: UnderstandingLevel;
  complexity: ComplexityScore;
  
  // Sources and relationships
  sources: SourceReference[];
  derivedFrom?: string[];
  relatedTo?: string[];
  influences?: string[];
  
  // Platform specifics
  platforms: PlatformMetadata[];
  
  // Tags and classification
  tags: string[];
  categories: string[];
  methodologies: string[];
  
  // Custom fields
  custom: Record<string, any>;
}

interface ConfidenceMetrics {
  overall: number;        // 0-1 overall confidence
  factual: number;        // Factual accuracy confidence
  logical: number;        // Logical consistency confidence
  creative: number;       // Creative quality confidence
  methodological: number; // Methodology application confidence
}

class FrontmatterGenerator {
  private schema: MetadataSchema;
  
  generateFrontmatter(document: Document): string {
    const metadata = this.extractMetadata(document);
    
    // Validate against schema
    this.validateMetadata(metadata);
    
    // Generate YAML frontmatter
    const yaml = this.serializeToYAML(metadata);
    
    return `---\n${yaml}\n---\n\n`;
  }
  
  private extractMetadata(document: Document): DocumentMetadata {
    return {
      id: document.id,
      title: document.title,
      type: document.type,
      status: document.status,
      
      created: document.createdAt,
      modified: document.modifiedAt,
      published: document.publishedAt,
      
      createdBy: document.agent,
      workflow: document.workflow,
      phase: document.currentPhase,
      
      confidence: this.calculateConfidence(document),
      understanding: this.assessUnderstanding(document),
      complexity: this.calculateComplexity(document),
      
      sources: this.extractSources(document),
      derivedFrom: document.derivedFrom,
      relatedTo: document.relatedTo,
      influences: document.influences,
      
      platforms: this.extractPlatformMetadata(document),
      
      tags: document.tags,
      categories: document.categories,
      methodologies: document.methodologies,
      
      custom: document.customMetadata || {}
    };
  }
  
  private serializeToYAML(metadata: DocumentMetadata): string {
    // Custom YAML serialization for better control
    const lines: string[] = [];
    
    // Core fields
    lines.push(`id: "${metadata.id}"`);
    lines.push(`title: "${this.escapeYAMLString(metadata.title)}"`);
    lines.push(`type: ${metadata.type}`);
    lines.push(`status: ${metadata.status}`);
    lines.push('');
    
    // Timestamps
    lines.push('# Timestamps');
    lines.push(`created: ${metadata.created.toISOString()}`);
    lines.push(`modified: ${metadata.modified.toISOString()}`);
    if (metadata.published) {
      lines.push(`published: ${metadata.published.toISOString()}`);
    }
    lines.push('');
    
    // Agent and workflow
    lines.push('# Workflow');
    lines.push(`created_by: ${metadata.createdBy}`);
    lines.push(`workflow: ${metadata.workflow}`);
    lines.push(`phase: ${metadata.phase}`);
    lines.push('');
    
    // Confidence metrics
    lines.push('# Quality Metrics');
    lines.push('confidence:');
    lines.push(`  overall: ${metadata.confidence.overall}`);
    lines.push(`  factual: ${metadata.confidence.factual}`);
    lines.push(`  logical: ${metadata.confidence.logical}`);
    lines.push(`  creative: ${metadata.confidence.creative}`);
    lines.push(`  methodological: ${metadata.confidence.methodological}`);
    lines.push(`understanding_level: ${metadata.understanding}`);
    lines.push(`complexity_score: ${metadata.complexity}`);
    lines.push('');
    
    // Sources and relationships
    if (metadata.sources.length > 0) {
      lines.push('# Sources');
      lines.push('sources:');
      metadata.sources.forEach(source => {
        lines.push(`  - url: "${source.url}"`);
        lines.push(`    title: "${this.escapeYAMLString(source.title)}"`);
        lines.push(`    confidence: ${source.confidence}`);
        lines.push(`    accessed: ${source.accessedAt.toISOString()}`);
      });
      lines.push('');
    }
    
    if (metadata.derivedFrom && metadata.derivedFrom.length > 0) {
      lines.push('# Relationships');
      lines.push('derived_from:');
      metadata.derivedFrom.forEach(ref => {
        lines.push(`  - "[[${ref}]]"`);
      });
    }
    
    if (metadata.relatedTo && metadata.relatedTo.length > 0) {
      lines.push('related_to:');
      metadata.relatedTo.forEach(ref => {
        lines.push(`  - "[[${ref}]]"`);
      });
      lines.push('');
    }
    
    // Platform metadata
    if (metadata.platforms.length > 0) {
      lines.push('# Platform Specific');
      lines.push('platforms:');
      metadata.platforms.forEach(platform => {
        lines.push(`  ${platform.type}:`);
        Object.entries(platform.metadata).forEach(([key, value]) => {
          lines.push(`    ${key}: ${this.serializeValue(value)}`);
        });
      });
      lines.push('');
    }
    
    // Tags and categories
    if (metadata.tags.length > 0) {
      lines.push('# Classification');
      lines.push(`tags: [${metadata.tags.map(tag => `"${tag}"`).join(', ')}]`);
    }
    
    if (metadata.categories.length > 0) {
      lines.push(`categories: [${metadata.categories.map(cat => `"${cat}"`).join(', ')}]`);
    }
    
    if (metadata.methodologies.length > 0) {
      lines.push(`methodologies: [${metadata.methodologies.map(m => `"${m}"`).join(', ')}]`);
    }
    
    return lines.join('\n');
  }
}
```

### Metadata Schema System:
```typescript
interface MetadataSchema {
  version: string;
  requiredFields: string[];
  optionalFields: string[];
  fieldTypes: Record<string, FieldType>;
  fieldValidators: Record<string, ValidationRule[]>;
}

interface FieldType {
  type: 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object';
  subtype?: string;
  allowNull?: boolean;
  enum?: string[];
}

class MetadataValidator {
  private schemas: Map<string, MetadataSchema> = new Map();
  
  constructor() {
    this.loadSchemas();
  }
  
  private loadSchemas(): void {
    // Core document schema
    this.schemas.set('document', {
      version: '1.0',
      requiredFields: ['id', 'title', 'type', 'status', 'created', 'modified', 'created_by'],
      optionalFields: ['published', 'workflow', 'phase', 'confidence', 'sources', 'tags'],
      fieldTypes: {
        id: { type: 'string' },
        title: { type: 'string' },
        type: { type: 'string', enum: ['content-brief', 'knowledge-synthesis', 'content-draft', 'platform-adaptation'] },
        status: { type: 'string', enum: ['draft', 'in-progress', 'review', 'completed', 'published'] },
        created: { type: 'date' },
        modified: { type: 'date' },
        published: { type: 'date', allowNull: true },
        created_by: { type: 'string', enum: ['Collector', 'Scholar', 'Creator', 'Adapter'] },
        confidence: { type: 'object', subtype: 'confidence-metrics' },
        sources: { type: 'array', subtype: 'source-reference' },
        tags: { type: 'array', subtype: 'string' }
      },
      fieldValidators: {
        id: [{ type: 'pattern', pattern: /^[a-zA-Z0-9-_]+$/ }],
        title: [{ type: 'minLength', value: 1 }, { type: 'maxLength', value: 200 }],
        confidence: [{ type: 'confidenceRange' }]
      }
    });
    
    // Platform-specific schemas
    this.schemas.set('linkedin', {
      version: '1.0',
      requiredFields: ['platform', 'optimized_length', 'professional_score'],
      optionalFields: ['hashtags', 'industry_insights', 'engagement_hooks'],
      fieldTypes: {
        platform: { type: 'string' },
        optimized_length: { type: 'number' },
        professional_score: { type: 'number' },
        hashtags: { type: 'array', subtype: 'string' },
        industry_insights: { type: 'array', subtype: 'string' },
        engagement_hooks: { type: 'array', subtype: 'string' }
      },
      fieldValidators: {
        optimized_length: [{ type: 'range', min: 1300, max: 2000 }],
        professional_score: [{ type: 'range', min: 0, max: 100 }],
        hashtags: [{ type: 'maxItems', value: 5 }]
      }
    });
  }
  
  validateMetadata(metadata: any, schemaName: string = 'document'): ValidationResult {
    const schema = this.schemas.get(schemaName);
    if (!schema) {
      throw new Error(`Unknown schema: ${schemaName}`);
    }
    
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];
    
    // Check required fields
    for (const field of schema.requiredFields) {
      if (!(field in metadata)) {
        errors.push({
          field,
          message: `Required field '${field}' is missing`,
          severity: 'error'
        });
      }
    }
    
    // Validate field types and values
    for (const [field, value] of Object.entries(metadata)) {
      const fieldType = schema.fieldTypes[field];
      if (!fieldType) {
        warnings.push({
          field,
          message: `Unknown field '${field}'`,
          severity: 'warning'
        });
        continue;
      }
      
      // Type validation
      const typeError = this.validateFieldType(field, value, fieldType);
      if (typeError) {
        errors.push(typeError);
      }
      
      // Custom validators
      const validators = schema.fieldValidators[field] || [];
      for (const validator of validators) {
        const validationError = this.runValidator(field, value, validator);
        if (validationError) {
          errors.push(validationError);
        }
      }
    }
    
    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }
}
```

### Confidence and Understanding Tracking:
```typescript
interface UnderstandingLevel {
  level: 'surface' | 'intermediate' | 'deep' | 'expert';
  score: number; // 0-1
  indicators: UnderstandingIndicator[];
}

interface UnderstandingIndicator {
  type: 'concept-grasp' | 'connection-made' | 'application-shown' | 'synthesis-achieved';
  confidence: number;
  evidence: string;
}

class ConfidenceTracker {
  calculateConfidence(document: Document): ConfidenceMetrics {
    return {
      overall: this.calculateOverallConfidence(document),
      factual: this.calculateFactualConfidence(document),
      logical: this.calculateLogicalConfidence(document),
      creative: this.calculateCreativeConfidence(document),
      methodological: this.calculateMethodologicalConfidence(document)
    };
  }
  
  private calculateOverallConfidence(document: Document): number {
    const weights = {
      sourceQuality: 0.3,
      methodologyConsistency: 0.25,
      logicalCoherence: 0.2,
      factualAccuracy: 0.15,
      completeness: 0.1
    };
    
    const scores = {
      sourceQuality: this.assessSourceQuality(document.sources),
      methodologyConsistency: this.assessMethodologyConsistency(document.methodologies),
      logicalCoherence: this.assessLogicalCoherence(document.content),
      factualAccuracy: this.assessFactualAccuracy(document.claims),
      completeness: this.assessCompleteness(document.acceptanceCriteria)
    };
    
    return Object.entries(weights).reduce((total, [key, weight]) => {
      return total + (scores[key] * weight);
    }, 0);
  }
  
  assessUnderstanding(document: Document): UnderstandingLevel {
    const indicators = this.identifyUnderstandingIndicators(document);
    const score = this.calculateUnderstandingScore(indicators);
    
    let level: UnderstandingLevel['level'] = 'surface';
    if (score >= 0.8) level = 'expert';
    else if (score >= 0.6) level = 'deep';
    else if (score >= 0.4) level = 'intermediate';
    
    return { level, score, indicators };
  }
  
  private identifyUnderstandingIndicators(document: Document): UnderstandingIndicator[] {
    const indicators: UnderstandingIndicator[] = [];
    
    // Look for concept explanations
    if (document.content.includes('explanation') || document.content.includes('concept')) {
      indicators.push({
        type: 'concept-grasp',
        confidence: 0.7,
        evidence: 'Document contains concept explanations'
      });
    }
    
    // Look for connections between ideas
    const connectionWords = ['because', 'therefore', 'leads to', 'results in', 'connects to'];
    if (connectionWords.some(word => document.content.toLowerCase().includes(word))) {
      indicators.push({
        type: 'connection-made',
        confidence: 0.8,
        evidence: 'Document shows causal relationships'
      });
    }
    
    // Look for practical applications
    if (document.content.includes('example') || document.content.includes('application')) {
      indicators.push({
        type: 'application-shown',
        confidence: 0.6,
        evidence: 'Document provides practical examples'
      });
    }
    
    // Look for synthesis of multiple sources
    if (document.sources.length > 2) {
      indicators.push({
        type: 'synthesis-achieved',
        confidence: 0.9,
        evidence: `Synthesizes ${document.sources.length} sources`
      });
    }
    
    return indicators;
  }
}
```

### Source and Relationship Management:
```typescript
interface SourceReference {
  url: string;
  title: string;
  author?: string;
  publishedDate?: Date;
  accessedAt: Date;
  confidence: number; // How much we trust this source
  relevance: number;  // How relevant to the document
  type: SourceType;
}

enum SourceType {
  WEBSITE = 'website',
  ACADEMIC = 'academic',
  BOOK = 'book',
  VIDEO = 'video',
  DOCUMENT = 'document',
  INTERVIEW = 'interview'
}

interface DocumentRelationship {
  type: RelationType;
  target: string; // Document ID or title
  strength: number; // 0-1 strength of relationship
  description: string;
}

enum RelationType {
  DERIVES_FROM = 'derives_from',
  BUILDS_ON = 'builds_on',
  CONTRADICTS = 'contradicts',
  SUPPORTS = 'supports',
  EXEMPLIFIES = 'exemplifies',
  GENERALIZES = 'generalizes'
}

class RelationshipManager {
  extractRelationships(document: Document): DocumentRelationship[] {
    const relationships: DocumentRelationship[] = [];
    
    // Extract explicit references
    const wikiLinks = this.extractWikiLinks(document.content);
    wikiLinks.forEach(link => {
      relationships.push({
        type: RelationType.BUILDS_ON,
        target: link,
        strength: 0.7,
        description: `References [[${link}]]`
      });
    });
    
    // Detect derivation relationships
    if (document.derivedFrom) {
      document.derivedFrom.forEach(source => {
        relationships.push({
          type: RelationType.DERIVES_FROM,
          target: source,
          strength: 0.9,
          description: `Derived from ${source}`
        });
      });
    }
    
    // Identify contradictions
    const contradictionKeywords = ['however', 'but', 'contradicts', 'opposes'];
    if (contradictionKeywords.some(keyword => 
      document.content.toLowerCase().includes(keyword))) {
      // This would require more sophisticated NLP to identify what it contradicts
      // For now, mark as potential contradiction
      relationships.push({
        type: RelationType.CONTRADICTS,
        target: 'unknown',
        strength: 0.3,
        description: 'Contains contradictory statements'
      });
    }
    
    return relationships;
  }
  
  private extractWikiLinks(content: string): string[] {
    const wikiLinkRegex = /\[\[([^\]]+)\]\]/g;
    const matches = [];
    let match;
    
    while ((match = wikiLinkRegex.exec(content)) !== null) {
      matches.push(match[1]);
    }
    
    return matches;
  }
}
```

### Platform-Specific Metadata:
```typescript
interface PlatformMetadata {
  type: PlatformType;
  metadata: Record<string, any>;
  optimizations: PlatformOptimization[];
}

interface PlatformOptimization {
  type: string;
  value: any;
  confidence: number;
}

class PlatformMetadataManager {
  generatePlatformMetadata(document: Document, platform: PlatformType): PlatformMetadata {
    switch (platform) {
      case 'linkedin':
        return this.generateLinkedInMetadata(document);
      case 'twitter':
        return this.generateTwitterMetadata(document);
      default:
        return this.generateGenericMetadata(document, platform);
    }
  }
  
  private generateLinkedInMetadata(document: Document): PlatformMetadata {
    return {
      type: 'linkedin',
      metadata: {
        professional_score: this.calculateProfessionalScore(document),
        target_length: this.calculateOptimalLength(document, 'linkedin'),
        industry_relevance: this.assessIndustryRelevance(document),
        engagement_potential: this.predictEngagement(document, 'linkedin'),
        hashtags: this.generateHashtags(document, 'linkedin'),
        call_to_action: this.suggestCallToAction(document, 'linkedin')
      },
      optimizations: [
        {
          type: 'tone_adjustment',
          value: 'professional',
          confidence: 0.8
        },
        {
          type: 'length_optimization',
          value: '1300-2000',
          confidence: 0.9
        }
      ]
    };
  }
  
  private generateTwitterMetadata(document: Document): PlatformMetadata {
    return {
      type: 'twitter',
      metadata: {
        thread_count: this.estimateThreadLength(document),
        viral_score: this.calculateViralPotential(document),
        engagement_hooks: this.identifyEngagementHooks(document),
        hashtags: this.generateHashtags(document, 'twitter'),
        character_efficiency: this.calculateCharacterEfficiency(document)
      },
      optimizations: [
        {
          type: 'thread_breaking',
          value: 'optimal',
          confidence: 0.85
        },
        {
          type: 'hook_generation',
          value: 'high_impact',
          confidence: 0.75
        }
      ]
    };
  }
}
```

### Testing
**Testing Framework:** Jest + User Acceptance Testing
**Test File Location:** `.flcm-core/tests/obsidian/metadata/`

**Performance Standards:**
- Metadata generation: <500ms per document
- Search by metadata: <3 seconds for any query
- Schema validation: <100ms per document
- Frontmatter parsing: <50ms per document

**Unit Tests:**
- YAML frontmatter generation and parsing
- Metadata schema validation
- Confidence calculation accuracy
- Understanding level assessment
- Source reference extraction
- Relationship mapping logic

**Integration Tests:**
- Complete metadata workflow
- Cross-platform metadata consistency
- Schema migration handling
- Metadata search and filtering
- Frontmatter update operations

**User Acceptance Tests:**
- User can find content using metadata filters in <5 seconds
- Metadata accuracy verified by user review (>95% satisfaction)
- Content relationships are correctly identified by users
- Platform-specific metadata enables successful adaptations
- Schema prevents data corruption in real-world usage

**Test Scenarios:**
```
tests/fixtures/metadata/
├── valid-metadata/
├── invalid-metadata/
├── schema-versions/
├── platform-specific/
├── confidence-samples/
├── relationship-examples/
└── user-acceptance/
    ├── search-scenarios/
    ├── relationship-validation/
    └── performance-benchmarks/
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_