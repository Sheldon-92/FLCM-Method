# Story 10.6: Knowledge Graph Visualization Support

## Status
Approved

## Story
**As a** user,  
**I want** to see connections between my content,  
**so that** I can discover patterns and gaps.

**Estimated Time:** 3-4 hours

## Acceptance Criteria
1. Users can visualize their content network and understand knowledge connections at a glance
2. Content relationships are clearly shown with meaningful visual links that aid navigation
3. Users can identify content clusters and knowledge gaps within 30 seconds of viewing
4. Visual patterns help users discover unexpected connections between their ideas
5. Orphan content is highlighted so users can better integrate isolated knowledge
6. Graph metrics provide actionable insights for improving knowledge base structure

## Tasks / Subtasks
- [ ] Implement node creation system (AC: 1)
  - [ ] Create GraphNodeGenerator class
  - [ ] Build node metadata extraction
  - [ ] Implement node positioning algorithms
  - [ ] Add node size calculation
  - [ ] Create node labeling system
  - [ ] Handle node update logic
- [ ] Build link type system (AC: 2)
  - [ ] Create LinkTypeClassifier service
  - [ ] Define semantic relationship types
  - [ ] Implement link strength calculation
  - [ ] Build link direction logic
  - [ ] Add link metadata support
  - [ ] Create link validation
- [ ] Implement tag-based coloring (AC: 3)
  - [ ] Create ColorSchemeManager
  - [ ] Build tag color mapping
  - [ ] Implement color harmonization
  - [ ] Add color accessibility support
  - [ ] Create color legend generation
  - [ ] Handle color conflicts
- [ ] Build cluster identification (AC: 4)
  - [ ] Create ClusterAnalyzer service
  - [ ] Implement clustering algorithms
  - [ ] Build cluster visualization
  - [ ] Add cluster metadata
  - [ ] Create cluster navigation
  - [ ] Implement cluster filtering
- [ ] Implement orphan detection (AC: 5)
  - [ ] Create OrphanDetector service
  - [ ] Build connectivity analysis
  - [ ] Implement orphan highlighting
  - [ ] Add orphan resolution suggestions
  - [ ] Create orphan reports
  - [ ] Build orphan cleanup tools
- [ ] Add graph metrics export (AC: 6)
  - [ ] Create GraphMetricsCalculator
  - [ ] Implement centrality measures
  - [ ] Build connectivity statistics
  - [ ] Add export formats (JSON, CSV)
  - [ ] Create metrics visualization
  - [ ] Implement trend analysis

## Dev Notes

### Knowledge Graph Architecture:
```typescript
interface KnowledgeGraph {
  nodes: GraphNode[];
  edges: GraphEdge[];
  clusters: GraphCluster[];
  metrics: GraphMetrics;
  metadata: GraphMetadata;
}

interface GraphNode {
  id: string;
  label: string;
  type: NodeType;
  size: number;
  color: string;
  position: Position;
  metadata: NodeMetadata;
  connections: number;
  centrality: CentralityMeasures;
}

interface GraphEdge {
  id: string;
  source: string;
  target: string;
  type: EdgeType;
  weight: number;
  bidirectional: boolean;
  metadata: EdgeMetadata;
  color?: string;
}

enum NodeType {
  DOCUMENT = 'document',
  CONCEPT = 'concept',
  METHODOLOGY = 'methodology',
  PERSON = 'person',
  TOPIC = 'topic',
  TAG = 'tag'
}

enum EdgeType {
  DERIVES_FROM = 'derives_from',
  BUILDS_ON = 'builds_on',
  CONTRADICTS = 'contradicts',
  SUPPORTS = 'supports',
  TEACHES = 'teaches',
  EXEMPLIFIES = 'exemplifies',
  MENTIONS = 'mentions',
  TAGGED_WITH = 'tagged_with'
}

class KnowledgeGraphBuilder {
  private vault: VaultManager;
  private linkAnalyzer: LinkAnalyzer;
  private clusterAnalyzer: ClusterAnalyzer;
  
  async buildGraph(documents: Document[]): Promise<KnowledgeGraph> {
    // Create nodes from documents
    const documentNodes = await this.createDocumentNodes(documents);
    
    // Create concept nodes from wiki links
    const conceptNodes = await this.createConceptNodes(documents);
    
    // Create tag nodes
    const tagNodes = await this.createTagNodes(documents);
    
    // Combine all nodes
    const allNodes = [...documentNodes, ...conceptNodes, ...tagNodes];
    
    // Create edges from relationships
    const edges = await this.createEdges(documents, allNodes);
    
    // Analyze clusters
    const clusters = await this.clusterAnalyzer.identifyClusters(allNodes, edges);
    
    // Calculate metrics
    const metrics = await this.calculateGraphMetrics(allNodes, edges);
    
    // Apply layout algorithm
    const positionedNodes = await this.applyLayout(allNodes, edges);
    
    return {
      nodes: positionedNodes,
      edges,
      clusters,
      metrics,
      metadata: {
        generated: new Date(),
        documentCount: documents.length,
        version: '1.0'
      }
    };
  }
  
  private async createDocumentNodes(documents: Document[]): Promise<GraphNode[]> {
    return documents.map(doc => {
      const connections = this.countDocumentConnections(doc, documents);
      const centrality = this.calculateNodeCentrality(doc.id, documents);
      
      return {
        id: doc.id,
        label: doc.title,
        type: NodeType.DOCUMENT,
        size: this.calculateNodeSize(doc, connections),
        color: this.getDocumentColor(doc),
        position: { x: 0, y: 0 }, // Will be set by layout algorithm
        metadata: {
          documentType: doc.type,
          agent: doc.createdBy,
          created: doc.createdAt,
          confidence: doc.metadata?.confidence?.overall || 0,
          wordCount: doc.content.split(/\s+/).length,
          tags: doc.tags || []
        },
        connections,
        centrality
      };
    });
  }
  
  private calculateNodeSize(document: Document, connections: number): number {
    // Base size on multiple factors
    let size = 10; // Base size
    
    // Size based on content length
    const wordCount = document.content.split(/\s+/).length;
    size += Math.min(wordCount / 100, 20); // Max 20 additional pixels from content
    
    // Size based on connections (network importance)
    size += connections * 2;
    
    // Size based on confidence
    if (document.metadata?.confidence?.overall) {
      size += document.metadata.confidence.overall * 10;
    }
    
    // Size based on sources
    if (document.sources) {
      size += document.sources.length * 1.5;
    }
    
    return Math.max(8, Math.min(50, size)); // Between 8 and 50 pixels
  }
  
  private getDocumentColor(document: Document): string {
    // Color based on document type
    const typeColors = {
      'content-brief': '#3B82F6',      // Blue
      'knowledge-synthesis': '#10B981', // Green
      'content-draft': '#F59E0B',      // Orange
      'platform-adaptation': '#8B5CF6', // Purple
      'concept-page': '#EF4444',       // Red
      'methodology': '#06B6D4',        // Cyan
      'reference': '#6B7280'           // Gray
    };
    
    return typeColors[document.type] || '#6B7280';
  }
}
```

### Link Type Classification:
```typescript
class LinkTypeClassifier {
  private patterns: Map<EdgeType, RegExp[]> = new Map();
  
  constructor() {
    this.initializePatterns();
  }
  
  private initializePatterns(): void {
    // Derivation patterns
    this.patterns.set(EdgeType.DERIVES_FROM, [
      /based on \[\[([^\]]+)\]\]/gi,
      /derived from \[\[([^\]]+)\]\]/gi,
      /building on \[\[([^\]]+)\]\]/gi
    ]);
    
    // Contradiction patterns
    this.patterns.set(EdgeType.CONTRADICTS, [
      /contradicts \[\[([^\]]+)\]\]/gi,
      /opposes \[\[([^\]]+)\]\]/gi,
      /disagrees with \[\[([^\]]+)\]\]/gi,
      /however,? \[\[([^\]]+)\]\]/gi
    ]);
    
    // Support patterns
    this.patterns.set(EdgeType.SUPPORTS, [
      /supports \[\[([^\]]+)\]\]/gi,
      /confirms \[\[([^\]]+)\]\]/gi,
      /validates \[\[([^\]]+)\]\]/gi,
      /as shown in \[\[([^\]]+)\]\]/gi
    ]);
    
    // Teaching patterns
    this.patterns.set(EdgeType.TEACHES, [
      /explains \[\[([^\]]+)\]\]/gi,
      /demonstrates \[\[([^\]]+)\]\]/gi,
      /illustrates \[\[([^\]]+)\]\]/gi,
      /example of \[\[([^\]]+)\]\]/gi
    ]);
  }
  
  classifyLink(sourceDoc: Document, targetId: string, context: string): EdgeClassification {
    const classifications: EdgeClassification[] = [];
    
    // Check each pattern type
    for (const [edgeType, patterns] of this.patterns) {
      for (const pattern of patterns) {
        const matches = context.match(pattern);
        if (matches) {
          classifications.push({
            type: edgeType,
            confidence: this.calculatePatternConfidence(edgeType, context),
            evidence: matches[0]
          });
        }
      }
    }
    
    // Analyze structural relationships
    const structuralType = this.analyzeStructuralRelationship(sourceDoc, targetId);
    if (structuralType) {
      classifications.push(structuralType);
    }
    
    // Return highest confidence classification
    classifications.sort((a, b) => b.confidence - a.confidence);
    return classifications[0] || {
      type: EdgeType.MENTIONS,
      confidence: 0.5,
      evidence: 'Generic mention'
    };
  }
  
  private analyzeStructuralRelationship(sourceDoc: Document, targetId: string): EdgeClassification | null {
    // Check document metadata relationships
    if (sourceDoc.derivedFrom?.includes(targetId)) {
      return {
        type: EdgeType.DERIVES_FROM,
        confidence: 0.9,
        evidence: 'Explicit derivation in metadata'
      };
    }
    
    // Check temporal relationships
    const targetDoc = this.vault.getDocument(targetId);
    if (targetDoc && sourceDoc.createdAt > targetDoc.createdAt) {
      // Newer documents likely build on older ones
      return {
        type: EdgeType.BUILDS_ON,
        confidence: 0.6,
        evidence: 'Temporal relationship (newer builds on older)'
      };
    }
    
    return null;
  }
  
  calculateLinkWeight(classification: EdgeClassification, sourceDoc: Document, targetDoc: Document): number {
    let weight = classification.confidence;
    
    // Adjust weight based on relationship type
    const typeWeights = {
      [EdgeType.DERIVES_FROM]: 1.0,
      [EdgeType.BUILDS_ON]: 0.8,
      [EdgeType.CONTRADICTS]: 0.9,
      [EdgeType.SUPPORTS]: 0.8,
      [EdgeType.TEACHES]: 0.7,
      [EdgeType.EXEMPLIFIES]: 0.6,
      [EdgeType.MENTIONS]: 0.3,
      [EdgeType.TAGGED_WITH]: 0.4
    };
    
    weight *= typeWeights[classification.type];
    
    // Adjust based on document quality
    if (sourceDoc.metadata?.confidence?.overall) {
      weight *= sourceDoc.metadata.confidence.overall;
    }
    
    if (targetDoc.metadata?.confidence?.overall) {
      weight *= targetDoc.metadata.confidence.overall;
    }
    
    return Math.max(0.1, Math.min(1.0, weight));
  }
}
```

### Color Scheme Management:
```typescript
interface ColorScheme {
  name: string;
  description: string;
  colors: ColorMapping[];
  accessible: boolean;
}

interface ColorMapping {
  category: string;
  color: string;
  textColor: string;
  priority: number;
}

class ColorSchemeManager {
  private schemes: Map<string, ColorScheme> = new Map();
  private activeScheme: string = 'default';
  
  constructor() {
    this.loadDefaultSchemes();
  }
  
  private loadDefaultSchemes(): void {
    // Default scheme - based on document types
    this.schemes.set('default', {
      name: 'Document Types',
      description: 'Colors based on document types',
      accessible: true,
      colors: [
        { category: 'content-brief', color: '#3B82F6', textColor: '#FFFFFF', priority: 1 },
        { category: 'knowledge-synthesis', color: '#10B981', textColor: '#FFFFFF', priority: 1 },
        { category: 'content-draft', color: '#F59E0B', textColor: '#000000', priority: 1 },
        { category: 'platform-adaptation', color: '#8B5CF6', textColor: '#FFFFFF', priority: 1 },
        { category: 'concept-page', color: '#EF4444', textColor: '#FFFFFF', priority: 1 },
        { category: 'methodology', color: '#06B6D4', textColor: '#000000', priority: 2 },
        { category: 'reference', color: '#6B7280', textColor: '#FFFFFF', priority: 3 }
      ]
    });
    
    // Agent-based scheme
    this.schemes.set('agents', {
      name: 'Agent Types',
      description: 'Colors based on which agent created the document',
      accessible: true,
      colors: [
        { category: 'Collector', color: '#1E40AF', textColor: '#FFFFFF', priority: 1 },
        { category: 'Scholar', color: '#059669', textColor: '#FFFFFF', priority: 1 },
        { category: 'Creator', color: '#D97706', textColor: '#FFFFFF', priority: 1 },
        { category: 'Adapter', color: '#7C3AED', textColor: '#FFFFFF', priority: 1 }
      ]
    });
    
    // Confidence-based scheme
    this.schemes.set('confidence', {
      name: 'Confidence Levels',
      description: 'Colors based on document confidence scores',
      accessible: true,
      colors: [
        { category: 'high', color: '#059669', textColor: '#FFFFFF', priority: 1 }, // > 0.8
        { category: 'medium', color: '#D97706', textColor: '#FFFFFF', priority: 2 }, // 0.5 - 0.8
        { category: 'low', color: '#DC2626', textColor: '#FFFFFF', priority: 3 }, // < 0.5
        { category: 'unknown', color: '#6B7280', textColor: '#FFFFFF', priority: 4 }
      ]
    });
  }
  
  applyColoring(nodes: GraphNode[], scheme: string = this.activeScheme): GraphNode[] {
    const colorScheme = this.schemes.get(scheme);
    if (!colorScheme) {
      console.warn(`Color scheme '${scheme}' not found, using default`);
      return this.applyColoring(nodes, 'default');
    }
    
    return nodes.map(node => {
      const color = this.getNodeColor(node, colorScheme);
      return { ...node, color };
    });
  }
  
  private getNodeColor(node: GraphNode, scheme: ColorScheme): string {
    // Try to match based on scheme type
    if (scheme.name === 'Document Types') {
      const mapping = scheme.colors.find(c => c.category === node.metadata.documentType);
      return mapping?.color || '#6B7280';
    }
    
    if (scheme.name === 'Agent Types') {
      const mapping = scheme.colors.find(c => c.category === node.metadata.agent);
      return mapping?.color || '#6B7280';
    }
    
    if (scheme.name === 'Confidence Levels') {
      const confidence = node.metadata.confidence || 0;
      let category = 'unknown';
      if (confidence > 0.8) category = 'high';
      else if (confidence > 0.5) category = 'medium';
      else if (confidence > 0) category = 'low';
      
      const mapping = scheme.colors.find(c => c.category === category);
      return mapping?.color || '#6B7280';
    }
    
    // Fallback to tag-based coloring
    return this.getTagBasedColor(node);
  }
  
  private getTagBasedColor(node: GraphNode): string {
    if (!node.metadata.tags || node.metadata.tags.length === 0) {
      return '#6B7280'; // Default gray
    }
    
    // Use first tag to determine color
    const firstTag = node.metadata.tags[0];
    return this.generateColorFromString(firstTag);
  }
  
  private generateColorFromString(str: string): string {
    // Generate consistent color from string hash
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    
    // Convert to HSL color
    const hue = Math.abs(hash) % 360;
    const saturation = 65; // Fixed saturation for consistency
    const lightness = 50;  // Fixed lightness for readability
    
    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  }
}
```

### Cluster Analysis:
```typescript
interface GraphCluster {
  id: string;
  name: string;
  nodes: string[];
  centerNode: string;
  cohesion: number; // 0-1 measure of cluster tightness
  tags: string[];
  topics: string[];
  averageConfidence: number;
}

class ClusterAnalyzer {
  async identifyClusters(nodes: GraphNode[], edges: GraphEdge[]): Promise<GraphCluster[]> {
    // Build adjacency matrix
    const adjacencyMatrix = this.buildAdjacencyMatrix(nodes, edges);
    
    // Apply clustering algorithm (using Louvain method)
    const communities = await this.louvainClustering(adjacencyMatrix);
    
    // Convert communities to clusters
    const clusters = this.communitiesToClusters(communities, nodes, edges);
    
    // Analyze cluster properties
    const analyzedClusters = clusters.map(cluster => 
      this.analyzeCluster(cluster, nodes, edges)
    );
    
    return analyzedClusters.filter(cluster => cluster.nodes.length >= 2);
  }
  
  private async louvainClustering(adjacencyMatrix: number[][]): Promise<number[][]> {
    // Simplified Louvain algorithm implementation
    const n = adjacencyMatrix.length;
    let communities: number[][] = [];
    
    // Initialize each node as its own community
    for (let i = 0; i < n; i++) {
      communities.push([i]);
    }
    
    let improved = true;
    let iterations = 0;
    const maxIterations = 100;
    
    while (improved && iterations < maxIterations) {
      improved = false;
      iterations++;
      
      for (let i = 0; i < n; i++) {
        const currentCommunity = this.findCommunity(i, communities);
        const bestCommunity = this.findBestCommunity(i, communities, adjacencyMatrix);
        
        if (bestCommunity !== currentCommunity) {
          // Move node to better community
          this.moveNodeToCommunity(i, currentCommunity, bestCommunity, communities);
          improved = true;
        }
      }
      
      // Merge small communities
      communities = this.mergeSmallCommunities(communities, 2);
    }
    
    return communities.filter(community => community.length > 0);
  }
  
  private analyzeCluster(cluster: GraphCluster, nodes: GraphNode[], edges: GraphEdge[]): GraphCluster {
    const clusterNodes = nodes.filter(node => cluster.nodes.includes(node.id));
    
    // Calculate cohesion (internal edge density)
    const internalEdges = edges.filter(edge => 
      cluster.nodes.includes(edge.source) && cluster.nodes.includes(edge.target)
    );
    const maxPossibleEdges = (cluster.nodes.length * (cluster.nodes.length - 1)) / 2;
    const cohesion = maxPossibleEdges > 0 ? internalEdges.length / maxPossibleEdges : 0;
    
    // Find center node (highest degree within cluster)
    const centerNode = this.findCenterNode(cluster.nodes, edges);
    
    // Extract common tags
    const allTags = clusterNodes.flatMap(node => node.metadata.tags || []);
    const tagCounts = new Map<string, number>();
    allTags.forEach(tag => {
      tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
    });
    
    const commonTags = Array.from(tagCounts.entries())
      .filter(([_, count]) => count >= Math.ceil(clusterNodes.length * 0.3)) // 30% threshold
      .map(([tag, _]) => tag)
      .slice(0, 5); // Top 5 tags
    
    // Calculate average confidence
    const confidenceScores = clusterNodes
      .map(node => node.metadata.confidence || 0)
      .filter(score => score > 0);
    const avgConfidence = confidenceScores.length > 0 
      ? confidenceScores.reduce((sum, score) => sum + score, 0) / confidenceScores.length 
      : 0;
    
    // Generate cluster name
    const clusterName = this.generateClusterName(commonTags, clusterNodes);
    
    return {
      ...cluster,
      name: clusterName,
      cohesion,
      centerNode,
      tags: commonTags,
      topics: this.extractTopics(clusterNodes),
      averageConfidence: avgConfidence
    };
  }
  
  private generateClusterName(tags: string[], nodes: GraphNode[]): string {
    if (tags.length > 0) {
      return tags.slice(0, 2).join(' + ');
    }
    
    // Fallback: use most common document type
    const typeCounts = new Map<string, number>();
    nodes.forEach(node => {
      const type = node.metadata.documentType || 'unknown';
      typeCounts.set(type, (typeCounts.get(type) || 0) + 1);
    });
    
    const mostCommonType = Array.from(typeCounts.entries())
      .sort((a, b) => b[1] - a[1])[0]?.[0] || 'Mixed';
    
    return `${mostCommonType} Cluster`;
  }
}
```

### Graph Metrics Calculator:
```typescript
interface GraphMetrics {
  overview: OverviewMetrics;
  connectivity: ConnectivityMetrics;
  centrality: CentralityMetrics;
  clusters: ClusterMetrics;
  temporal: TemporalMetrics;
}

interface OverviewMetrics {
  nodeCount: number;
  edgeCount: number;
  density: number; // edges / max possible edges
  averageDegree: number;
  maxDegree: number;
  components: number; // number of disconnected components
}

class GraphMetricsCalculator {
  calculateMetrics(graph: KnowledgeGraph): GraphMetrics {
    return {
      overview: this.calculateOverview(graph),
      connectivity: this.calculateConnectivity(graph),
      centrality: this.calculateCentrality(graph),
      clusters: this.calculateClusterMetrics(graph),
      temporal: this.calculateTemporal(graph)
    };
  }
  
  private calculateOverview(graph: KnowledgeGraph): OverviewMetrics {
    const nodeCount = graph.nodes.length;
    const edgeCount = graph.edges.length;
    const maxPossibleEdges = (nodeCount * (nodeCount - 1)) / 2;
    const density = maxPossibleEdges > 0 ? edgeCount / maxPossibleEdges : 0;
    
    // Calculate degree distribution
    const degrees = graph.nodes.map(node => node.connections);
    const averageDegree = degrees.reduce((sum, degree) => sum + degree, 0) / nodeCount;
    const maxDegree = Math.max(...degrees);
    
    // Count connected components
    const components = this.countComponents(graph);
    
    return {
      nodeCount,
      edgeCount,
      density,
      averageDegree,
      maxDegree,
      components
    };
  }
  
  private calculateConnectivity(graph: KnowledgeGraph): ConnectivityMetrics {
    // Identify hub nodes (nodes with high degree)
    const sortedByDegree = [...graph.nodes].sort((a, b) => b.connections - a.connections);
    const hubs = sortedByDegree.slice(0, Math.ceil(graph.nodes.length * 0.1)); // Top 10%
    
    // Identify bridge edges (edges whose removal increases components)
    const bridges = this.findBridgeEdges(graph);
    
    // Calculate clustering coefficient
    const clusteringCoefficient = this.calculateGlobalClustering(graph);
    
    // Identify orphan nodes
    const orphans = graph.nodes.filter(node => node.connections === 0);
    
    return {
      hubs: hubs.map(node => ({ id: node.id, label: node.label, degree: node.connections })),
      bridges: bridges.length,
      clusteringCoefficient,
      orphanCount: orphans.length,
      orphans: orphans.map(node => ({ id: node.id, label: node.label }))
    };
  }
  
  private calculateCentrality(graph: KnowledgeGraph): CentralityMetrics {
    // Calculate various centrality measures
    const betweennessCentrality = this.calculateBetweennessCentrality(graph);
    const closenessCentrality = this.calculateClosenessCentrality(graph);
    const eigenvectorCentrality = this.calculateEigenvectorCentrality(graph);
    
    // Identify most central nodes by each measure
    const topBetweenness = this.getTopNodes(betweennessCentrality, 5);
    const topCloseness = this.getTopNodes(closenessCentrality, 5);
    const topEigenvector = this.getTopNodes(eigenvectorCentrality, 5);
    
    return {
      betweenness: topBetweenness,
      closeness: topCloseness,
      eigenvector: topEigenvector,
      averageBetweenness: this.calculateAverage(betweennessCentrality),
      averageCloseness: this.calculateAverage(closenessCentrality),
      averageEigenvector: this.calculateAverage(eigenvectorCentrality)
    };
  }
  
  exportMetrics(metrics: GraphMetrics, format: 'json' | 'csv'): string {
    if (format === 'json') {
      return JSON.stringify(metrics, null, 2);
    }
    
    if (format === 'csv') {
      return this.convertToCSV(metrics);
    }
    
    throw new Error(`Unsupported export format: ${format}`);
  }
  
  private convertToCSV(metrics: GraphMetrics): string {
    const rows = [
      ['Metric Category', 'Metric Name', 'Value'],
      
      // Overview metrics
      ['Overview', 'Node Count', metrics.overview.nodeCount],
      ['Overview', 'Edge Count', metrics.overview.edgeCount],
      ['Overview', 'Density', metrics.overview.density.toFixed(3)],
      ['Overview', 'Average Degree', metrics.overview.averageDegree.toFixed(2)],
      ['Overview', 'Max Degree', metrics.overview.maxDegree],
      ['Overview', 'Connected Components', metrics.overview.components],
      
      // Connectivity metrics
      ['Connectivity', 'Hub Count', metrics.connectivity.hubs.length],
      ['Connectivity', 'Bridge Count', metrics.connectivity.bridges],
      ['Connectivity', 'Clustering Coefficient', metrics.connectivity.clusteringCoefficient.toFixed(3)],
      ['Connectivity', 'Orphan Count', metrics.connectivity.orphanCount],
      
      // Centrality metrics
      ['Centrality', 'Average Betweenness', metrics.centrality.averageBetweenness.toFixed(3)],
      ['Centrality', 'Average Closeness', metrics.centrality.averageCloseness.toFixed(3)],
      ['Centrality', 'Average Eigenvector', metrics.centrality.averageEigenvector.toFixed(3)]
    ];
    
    return rows.map(row => row.join(',')).join('\n');
  }
}
```

### Testing
**Testing Framework:** Jest
**Test File Location:** `.flcm-core/tests/obsidian/graph/`

**Unit Tests:**
- Node creation and metadata extraction
- Link type classification accuracy
- Color scheme application
- Cluster identification algorithms
- Graph metrics calculations
- Orphan node detection

**Integration Tests:**
- Full graph generation workflow
- Multi-document graph building
- Graph visualization data export
- Performance with large graphs
- Graph update and maintenance

**Performance Tests:**
- Graph generation speed benchmarks
- Memory usage with large graphs
- Clustering algorithm performance
- Real-time graph updates
- Export format generation speed

**Test Data:**
```
tests/fixtures/graph/
├── small-graph/
├── large-graph/
├── disconnected-components/
├── highly-connected/
├── cluster-examples/
└── temporal-sequences/
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_