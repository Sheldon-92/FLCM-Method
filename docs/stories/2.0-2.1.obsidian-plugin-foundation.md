# Story 2.0-2.1: Obsidian Plugin Foundation

## Status
Draft

## Story
**As a** knowledge worker,  
**I want** FLCM to integrate deeply with my Obsidian vault,  
**so that** all my insights and content become part of my permanent knowledge base.

## Acceptance Criteria
1. Obsidian plugin installable via community plugins or BRAT
2. Bidirectional sync between FLCM documents and vault
3. Conflict resolution for simultaneous edits
4. Custom frontmatter for FLCM metadata
5. Settings page for sync preferences and vault location
6. Real-time sync status indicator in Obsidian

## Tasks / Subtasks
- [ ] Task 1: Create Obsidian plugin structure (AC: 1)
  - [ ] Subtask 1.1: Set up plugin manifest and package.json
  - [ ] Subtask 1.2: Implement plugin main class extending Plugin
  - [ ] Subtask 1.3: Configure build system for Obsidian compatibility
  - [ ] Subtask 1.4: Create plugin submission for community plugins

- [ ] Task 2: Implement bidirectional sync (AC: 2)
  - [ ] Subtask 2.1: Create file watcher for vault changes
  - [ ] Subtask 2.2: Implement FLCM‚ÜíObsidian sync engine
  - [ ] Subtask 2.3: Build Obsidian‚ÜíFLCM sync engine
  - [ ] Subtask 2.4: Add queue management for sync operations

- [ ] Task 3: Build conflict resolution system (AC: 3)
  - [ ] Subtask 3.1: Implement three-way merge algorithm
  - [ ] Subtask 3.2: Create conflict UI for manual resolution
  - [ ] Subtask 3.3: Add automatic conflict resolution rules
  - [ ] Subtask 3.4: Build conflict history tracking

- [ ] Task 4: Design custom frontmatter schema (AC: 4)
  - [ ] Subtask 4.1: Define FLCM metadata structure
  - [ ] Subtask 4.2: Create frontmatter parser/serializer
  - [ ] Subtask 4.3: Implement metadata validation
  - [ ] Subtask 4.4: Add migration for existing documents

- [ ] Task 5: Create settings interface (AC: 5)
  - [ ] Subtask 5.1: Build settings tab UI
  - [ ] Subtask 5.2: Implement vault path configuration
  - [ ] Subtask 5.3: Add sync frequency options
  - [ ] Subtask 5.4: Create advanced settings for power users

- [ ] Task 6: Implement sync status indicator (AC: 6)
  - [ ] Subtask 6.1: Create status bar item
  - [ ] Subtask 6.2: Add sync progress visualization
  - [ ] Subtask 6.3: Implement error state display
  - [ ] Subtask 6.4: Build sync history viewer

## Dev Notes

### Obsidian Plugin Architecture
```typescript
// main.ts - Plugin entry point
import { Plugin, Notice, TFile, TFolder } from 'obsidian';
import { FLCMSyncEngine } from './sync-engine';
import { FLCMSettingTab } from './settings';

export default class FLCMPlugin extends Plugin {
    syncEngine: FLCMSyncEngine;
    settings: FLCMSettings;
    statusBarItem: HTMLElement;

    async onload() {
        // Load settings
        await this.loadSettings();
        
        // Initialize sync engine
        this.syncEngine = new FLCMSyncEngine(this.app, this.settings);
        
        // Set up file watchers
        this.registerEvent(
            this.app.vault.on('create', (file) => {
                if (file instanceof TFile) {
                    this.syncEngine.onFileCreated(file);
                }
            })
        );
        
        this.registerEvent(
            this.app.vault.on('modify', (file) => {
                if (file instanceof TFile) {
                    this.syncEngine.onFileModified(file);
                }
            })
        );
        
        // Add status bar item
        this.statusBarItem = this.addStatusBarItem();
        this.updateStatusBar('FLCM: Ready');
        
        // Add settings tab
        this.addSettingTab(new FLCMSettingTab(this.app, this));
        
        // Start sync engine
        await this.syncEngine.start();
    }
}
```

### Sync Engine Implementation
```typescript
// sync-engine.ts
export class FLCMSyncEngine {
    private syncQueue: SyncOperation[] = [];
    private conflictResolver: ConflictResolver;
    private flcmClient: FLCMClient;
    
    constructor(app: App, settings: FLCMSettings) {
        this.app = app;
        this.settings = settings;
        this.conflictResolver = new ConflictResolver();
        this.flcmClient = new FLCMClient(settings.flcmPath);
    }
    
    async syncDocument(file: TFile, direction: 'to-flcm' | 'to-obsidian') {
        const operation: SyncOperation = {
            file,
            direction,
            timestamp: Date.now(),
            status: 'pending'
        };
        
        this.syncQueue.push(operation);
        await this.processSyncQueue();
    }
    
    private async processSyncQueue() {
        while (this.syncQueue.length > 0) {
            const op = this.syncQueue.shift();
            
            try {
                if (op.direction === 'to-flcm') {
                    await this.syncToFLCM(op.file);
                } else {
                    await this.syncToObsidian(op.file);
                }
                
                op.status = 'completed';
            } catch (error) {
                op.status = 'failed';
                op.error = error;
                
                // Handle conflict
                if (error.type === 'conflict') {
                    await this.handleConflict(op);
                }
            }
        }
    }
    
    private async handleConflict(operation: SyncOperation) {
        const localContent = await this.app.vault.read(operation.file);
        const remoteContent = await this.flcmClient.read(operation.file.path);
        const baseContent = await this.getBaseContent(operation.file);
        
        const resolution = await this.conflictResolver.resolve(
            baseContent,
            localContent,
            remoteContent
        );
        
        if (resolution.type === 'auto') {
            await this.applyResolution(operation.file, resolution.content);
        } else {
            await this.showConflictUI(operation.file, resolution);
        }
    }
}
```

### Frontmatter Schema
```yaml
---
flcm:
  version: "2.0"
  layer: "mentor"  # mentor | creator | publisher
  framework: "socratic"
  timestamp: 2025-01-31T10:00:00Z
  session_id: "uuid-here"
  metadata:
    depth_level: 3
    voice_profile: "analytical"
    audience: "technical"
    core_message: "Key insight here"
  connections:
    - "[[Related Note 1]]"
    - "[[Related Note 2]]"
  tags:
    - "#flcm/insight"
    - "#framework/socratic"
---
```

### Conflict Resolution
```typescript
// conflict-resolver.ts
export class ConflictResolver {
    async resolve(base: string, local: string, remote: string): Promise<Resolution> {
        // Try automatic three-way merge
        const merged = this.threeWayMerge(base, local, remote);
        
        if (merged.conflicts.length === 0) {
            return {
                type: 'auto',
                content: merged.result
            };
        }
        
        // Check resolution rules
        const ruleBasedResolution = this.applyRules(merged.conflicts);
        if (ruleBasedResolution) {
            return {
                type: 'auto',
                content: ruleBasedResolution
            };
        }
        
        // Require manual resolution
        return {
            type: 'manual',
            conflicts: merged.conflicts,
            suggestions: this.generateSuggestions(merged.conflicts)
        };
    }
    
    private threeWayMerge(base: string, local: string, remote: string): MergeResult {
        const baseLines = base.split('\n');
        const localLines = local.split('\n');
        const remoteLines = remote.split('\n');
        
        // Use diff3 algorithm
        const patches = this.computePatches(baseLines, localLines, remoteLines);
        const result = this.applyPatches(baseLines, patches);
        
        return result;
    }
}
```

### Settings Interface
```typescript
// settings.ts
export class FLCMSettingTab extends PluginSettingTab {
    plugin: FLCMPlugin;
    
    display(): void {
        const { containerEl } = this;
        containerEl.empty();
        
        containerEl.createEl('h2', { text: 'FLCM Integration Settings' });
        
        // FLCM Path
        new Setting(containerEl)
            .setName('FLCM Installation Path')
            .setDesc('Path to your FLCM installation')
            .addText(text => text
                .setPlaceholder('/Users/you/.flcm')
                .setValue(this.plugin.settings.flcmPath)
                .onChange(async (value) => {
                    this.plugin.settings.flcmPath = value;
                    await this.plugin.saveSettings();
                }));
        
        // Sync Mode
        new Setting(containerEl)
            .setName('Sync Mode')
            .setDesc('How documents should be synchronized')
            .addDropdown(dropdown => dropdown
                .addOption('manual', 'Manual')
                .addOption('auto', 'Automatic')
                .addOption('realtime', 'Real-time')
                .setValue(this.plugin.settings.syncMode)
                .onChange(async (value) => {
                    this.plugin.settings.syncMode = value;
                    await this.plugin.saveSettings();
                }));
        
        // Conflict Resolution
        new Setting(containerEl)
            .setName('Conflict Resolution')
            .setDesc('How to handle sync conflicts')
            .addDropdown(dropdown => dropdown
                .addOption('ask', 'Always Ask')
                .addOption('local', 'Prefer Local')
                .addOption('remote', 'Prefer Remote')
                .addOption('newest', 'Prefer Newest')
                .setValue(this.plugin.settings.conflictResolution)
                .onChange(async (value) => {
                    this.plugin.settings.conflictResolution = value;
                    await this.plugin.saveSettings();
                }));
    }
}
```

### Status Indicator
```typescript
// status-indicator.ts
export class SyncStatusIndicator {
    private statusBarItem: HTMLElement;
    private syncStatus: SyncStatus = 'idle';
    private lastSync: Date | null = null;
    
    constructor(statusBarItem: HTMLElement) {
        this.statusBarItem = statusBarItem;
        this.updateDisplay();
    }
    
    updateStatus(status: SyncStatus, details?: string) {
        this.syncStatus = status;
        
        if (status === 'completed') {
            this.lastSync = new Date();
        }
        
        this.updateDisplay(details);
    }
    
    private updateDisplay(details?: string) {
        const icon = this.getStatusIcon();
        const text = this.getStatusText();
        
        this.statusBarItem.empty();
        this.statusBarItem.createSpan({ 
            text: `${icon} FLCM: ${text}`,
            cls: `flcm-status-${this.syncStatus}`
        });
        
        if (details) {
            this.statusBarItem.title = details;
        }
    }
    
    private getStatusIcon(): string {
        switch (this.syncStatus) {
            case 'syncing': return 'üîÑ';
            case 'completed': return '‚úÖ';
            case 'error': return '‚ùå';
            case 'conflict': return '‚ö†Ô∏è';
            default: return 'üí´';
        }
    }
}
```

### Performance Requirements
- Plugin load time: <500ms
- Sync operation: <2s per document
- Conflict detection: <100ms
- Status update: <50ms

### Testing
- **Test Location**: `tests/obsidian-plugin/`
- **Integration Tests**: `tests/obsidian-plugin/sync/`
- **Conflict Tests**: `tests/obsidian-plugin/conflicts/`
- **Performance Tests**: Test with vaults of 10k+ notes
- **Compatibility**: Test with Obsidian 1.0+

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-31 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
*To be populated during implementation*

### Agent Model Used
*TBD*

### Debug Log References
*TBD*

### Completion Notes List
*TBD*

### File List
*TBD*

## QA Results
*To be populated during QA*