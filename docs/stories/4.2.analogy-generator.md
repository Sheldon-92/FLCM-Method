# Story 4.2: Analogy and Explanation Generator

## Status
Approved

## Story
**As a** user,  
**I want** complex concepts explained through analogies,  
**so that** I can understand through familiar references.

**Estimated Time:** 4-5 hours

## Acceptance Criteria
1. Domain-specific analogy database created
2. Analogy relevance scoring
3. Multiple analogy generation for same concept
4. Cultural context consideration
5. User feedback on analogy effectiveness
6. Analogy evolution based on understanding level

## Tasks / Subtasks
- [ ] Create domain-specific analogy database (AC: 1)
  - [ ] Build AnalogyDatabase class
  - [ ] Define analogy categories (science, everyday, pop culture, etc.)
  - [ ] Create seed analogies for common concepts
  - [ ] Implement analogy storage structure
  - [ ] Add domain tagging system
  - [ ] Build analogy search interface
- [ ] Implement relevance scoring (AC: 2)
  - [ ] Create AnalogyScorer class
  - [ ] Calculate conceptual similarity
  - [ ] Measure complexity match
  - [ ] Assess familiarity score
  - [ ] Factor in user background
  - [ ] Generate relevance ranking
- [ ] Build multiple analogy generator (AC: 3)
  - [ ] Create AnalogyGenerator class
  - [ ] Generate 3-5 analogies per concept
  - [ ] Ensure diversity in analogy types
  - [ ] Vary complexity levels
  - [ ] Mix domains for variety
  - [ ] Avoid repetitive patterns
- [ ] Add cultural context support (AC: 4)
  - [ ] Define cultural context parameters
  - [ ] Tag analogies with cultural markers
  - [ ] Filter inappropriate references
  - [ ] Adapt examples to user culture
  - [ ] Handle regional variations
  - [ ] Provide universal fallbacks
- [ ] Implement feedback system (AC: 5)
  - [ ] Create feedback collection interface
  - [ ] Track analogy effectiveness scores
  - [ ] Identify successful patterns
  - [ ] Record failed analogies
  - [ ] Build improvement suggestions
  - [ ] Update analogy rankings
- [ ] Build adaptive evolution (AC: 6)
  - [ ] Create AnalogyEvolver class
  - [ ] Adjust complexity with understanding
  - [ ] Progress from concrete to abstract
  - [ ] Refine based on feedback
  - [ ] Generate hybrid analogies
  - [ ] Track evolution history

## Dev Notes

### Analogy Architecture:
```typescript
interface Analogy {
  id: string;
  sourceConc

ept: string;
  targetDomain: string;
  explanation: string;
  complexity: DepthLevel;
  culturalContext?: string[];
  effectiveness: number; // 0-1 based on feedback
  tags: string[];
}

class AnalogyGenerator {
  async generate(
    concept: string,
    userProfile: UserLearningProfile,
    count: number = 3
  ): Promise<Analogy[]> {
    const candidates = await this.findCandidates(concept);
    const scored = this.scoreForUser(candidates, userProfile);
    const diverse = this.ensureDiversity(scored);
    
    return diverse.slice(0, count).map(a => 
      this.adaptToUser(a, userProfile)
    );
  }
  
  private ensureDiversity(analogies: Analogy[]): Analogy[] {
    // Ensure mix of domains, complexity, and styles
    const domains = new Set<string>();
    const selected: Analogy[] = [];
    
    for (const analogy of analogies) {
      if (!domains.has(analogy.targetDomain)) {
        selected.push(analogy);
        domains.add(analogy.targetDomain);
      }
    }
    
    return selected;
  }
}
```

### Analogy Database Structure:
```typescript
interface AnalogyDatabase {
  analogies: Map<string, Analogy[]>;
  domains: Set<string>;
  culturalContexts: Map<string, CulturalMarkers>;
  
  // Seed examples
  seedAnalogies: {
    'machine-learning': [
      {
        targetDomain: 'cooking',
        explanation: 'Like a chef learning recipes by tasting many dishes...'
      },
      {
        targetDomain: 'sports',
        explanation: 'Like an athlete improving through practice and feedback...'
      },
      {
        targetDomain: 'gardening',
        explanation: 'Like a gardener learning which plants thrive in which conditions...'
      }
    ]
  };
}
```

### Relevance Scoring:
```typescript
class AnalogyScorer {
  score(
    analogy: Analogy,
    concept: string,
    userProfile: UserLearningProfile
  ): RelevanceScore {
    const conceptualSimilarity = this.calculateSimilarity(
      analogy.sourceConcept,
      concept
    );
    
    const familiarityScore = this.assessFamiliarity(
      analogy.targetDomain,
      userProfile
    );
    
    const complexityMatch = this.matchComplexity(
      analogy.complexity,
      userProfile.preferredDepth
    );
    
    const culturalFit = this.checkCulturalFit(
      analogy.culturalContext,
      userProfile.culture
    );
    
    return {
      overall: this.weightedAverage([
        conceptualSimilarity * 0.3,
        familiarityScore * 0.3,
        complexityMatch * 0.2,
        culturalFit * 0.1,
        analogy.effectiveness * 0.1
      ]),
      breakdown: {
        conceptual: conceptualSimilarity,
        familiarity: familiarityScore,
        complexity: complexityMatch,
        cultural: culturalFit,
        historical: analogy.effectiveness
      }
    };
  }
}
```

### Cultural Context Handling:
```typescript
interface CulturalContext {
  region: string;
  language: string;
  commonReferences: string[];
  avoidTopics: string[];
  preferredDomains: string[];
}

class CulturalAdapter {
  adapt(analogy: Analogy, context: CulturalContext): Analogy {
    // Check if analogy is appropriate
    if (this.hasTabooTopics(analogy, context)) {
      return this.findAlternative(analogy, context);
    }
    
    // Localize references
    const localized = this.localizeReferences(analogy, context);
    
    // Adjust formality
    const adjusted = this.adjustFormality(localized, context);
    
    return adjusted;
  }
}
```

### Feedback Collection:
```typescript
interface AnalogyFeedback {
  analogyId: string;
  helpful: boolean;
  clarityScore: number; // 1-5
  relevanceScore: number; // 1-5
  suggestion?: string;
  preferredAlternative?: string;
}

class FeedbackProcessor {
  process(feedback: AnalogyFeedback): void {
    // Update effectiveness score
    this.updateEffectiveness(feedback.analogyId, feedback);
    
    // Learn patterns
    if (feedback.helpful) {
      this.reinforcePattern(feedback.analogyId);
    } else {
      this.weakenPattern(feedback.analogyId);
    }
    
    // Extract insights
    if (feedback.suggestion) {
      this.extractInsight(feedback.suggestion);
    }
  }
}
```

### Evolution Strategy:
```typescript
class AnalogyEvolver {
  evolve(
    currentAnalogy: Analogy,
    userProgress: LearningProgress
  ): Analogy {
    // Start concrete, move to abstract
    if (userProgress.comprehension < 0.5) {
      return this.makeConcrete(currentAnalogy);
    }
    
    if (userProgress.comprehension > 0.8) {
      return this.makeAbstract(currentAnalogy);
    }
    
    // Refine based on feedback
    return this.refineAnalogy(currentAnalogy, userProgress.feedback);
  }
  
  private makeConcrete(analogy: Analogy): Analogy {
    // Add specific examples
    // Use everyday objects
    // Include visual descriptions
    return { ...analogy, /* concrete modifications */ };
  }
  
  private makeAbstract(analogy: Analogy): Analogy {
    // Focus on principles
    // Use theoretical frameworks
    // Reduce specific details
    return { ...analogy, /* abstract modifications */ };
  }
}
```

### Example Analogies by Level:
```typescript
// ELI5 Level
"AI is like a very smart robot friend who learns by looking at lots of pictures"

// Beginner Level
"Machine learning is like teaching a child to recognize animals by showing them many examples"

// Intermediate Level
"Neural networks function like a team of specialists, each examining different features and voting on the answer"

// Advanced Level
"Transformer architecture parallels distributed computing systems with attention mechanisms serving as dynamic routing"

// Expert Level
"The attention mechanism implements a differentiable dictionary lookup with learned query-key-value projections"
```

### Testing
**Testing Framework:** Jest
**Test File Location:** `.flcm-core/tests/scholar/`

**Unit Tests:**
- Analogy generation for various concepts
- Relevance scoring accuracy
- Cultural adaptation
- Feedback processing
- Evolution progression

**Test Data:**
```
tests/fixtures/analogies/
├── concept-analogies.json
├── cultural-contexts.json
├── user-profiles.json
└── feedback-samples.json
```

**Integration Tests:**
- Multi-analogy generation
- Adaptive evolution over time
- Cultural sensitivity
- Feedback-driven improvement

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_