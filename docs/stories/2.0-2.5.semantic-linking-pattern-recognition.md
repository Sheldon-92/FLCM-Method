# Story 2.0-2.5: Semantic Linking and Pattern Recognition

## Status
Draft

## Story
**As a** researcher,  
**I want** FLCM to automatically connect related content,  
**so that** I can discover non-obvious relationships.

## Acceptance Criteria
1. Semantic analysis identifies related documents
2. Automatic backlink suggestions
3. Pattern detection across multiple documents
4. Topic clustering and tag suggestions
5. Similarity scores for document pairs
6. Manual override for auto-connections

## Tasks / Subtasks
- [ ] Task 1: Implement semantic analysis (AC: 1)
  - [ ] Subtask 1.1: Set up embedding generation pipeline
  - [ ] Subtask 1.2: Create document vectorization
  - [ ] Subtask 1.3: Build similarity computation engine
  - [ ] Subtask 1.4: Implement caching for embeddings

- [ ] Task 2: Build backlink suggestion system (AC: 2)
  - [ ] Subtask 2.1: Create link candidate detection
  - [ ] Subtask 2.2: Implement relevance scoring
  - [ ] Subtask 2.3: Build suggestion UI
  - [ ] Subtask 2.4: Add batch suggestion processing

- [ ] Task 3: Create pattern detection (AC: 3)
  - [ ] Subtask 3.1: Implement sequence pattern mining
  - [ ] Subtask 3.2: Build co-occurrence analysis
  - [ ] Subtask 3.3: Create theme extraction
  - [ ] Subtask 3.4: Add temporal pattern detection

- [ ] Task 4: Develop clustering system (AC: 4)
  - [ ] Subtask 4.1: Implement topic modeling (LDA/BERT)
  - [ ] Subtask 4.2: Create hierarchical clustering
  - [ ] Subtask 4.3: Build tag generation from clusters
  - [ ] Subtask 4.4: Add cluster visualization

- [ ] Task 5: Calculate similarity scores (AC: 5)
  - [ ] Subtask 5.1: Define similarity metrics
  - [ ] Subtask 5.2: Create pairwise comparison engine
  - [ ] Subtask 5.3: Build similarity matrix
  - [ ] Subtask 5.4: Implement incremental updates

- [ ] Task 6: Add manual override system (AC: 6)
  - [ ] Subtask 6.1: Create override UI
  - [ ] Subtask 6.2: Build preference storage
  - [ ] Subtask 6.3: Implement learning from overrides
  - [ ] Subtask 6.4: Add bulk override management

## Dev Notes

### Semantic Analysis Architecture
```typescript
// semantic-analyzer.ts
class SemanticAnalyzer {
    private embedder: EmbeddingService;
    private cache: EmbeddingCache;
    private similarity: SimilarityEngine;
    
    async analyzeDocument(document: Document): Promise<SemanticProfile> {
        // Generate embeddings
        const embedding = await this.getEmbedding(document);
        
        // Extract key concepts
        const concepts = await this.extractConcepts(document);
        
        // Identify themes
        const themes = await this.identifyThemes(document);
        
        // Find related documents
        const related = await this.findRelated(embedding);
        
        return {
            embedding,
            concepts,
            themes,
            related,
            timestamp: Date.now()
        };
    }
    
    private async getEmbedding(document: Document): Promise<Float32Array> {
        // Check cache first
        const cached = await this.cache.get(document.id);
        if (cached && !this.isStale(cached, document)) {
            return cached.embedding;
        }
        
        // Generate new embedding
        const text = this.preprocessText(document.content);
        const embedding = await this.embedder.embed(text);
        
        // Cache for future use
        await this.cache.set(document.id, {
            embedding,
            documentHash: this.hash(document.content),
            timestamp: Date.now()
        });
        
        return embedding;
    }
    
    private async findRelated(embedding: Float32Array): Promise<RelatedDocument[]> {
        // Search vector database for similar documents
        const candidates = await this.similarity.search(embedding, {
            topK: 20,
            threshold: 0.7
        });
        
        // Re-rank using additional signals
        const reranked = this.rerank(candidates);
        
        return reranked.slice(0, 10);
    }
}
```

### Embedding Generation
```typescript
// embedding-service.ts
class EmbeddingService {
    private model: TransformerModel;
    private tokenizer: Tokenizer;
    
    async embed(text: string): Promise<Float32Array> {
        // Tokenize text
        const tokens = this.tokenizer.encode(text, {
            maxLength: 512,
            truncation: true
        });
        
        // Generate embeddings using local model
        const output = await this.model.forward(tokens);
        
        // Pool embeddings (mean pooling)
        const pooled = this.meanPool(output.lastHiddenState, tokens.attentionMask);
        
        // Normalize
        return this.normalize(pooled);
    }
    
    async embedBatch(texts: string[]): Promise<Float32Array[]> {
        // Batch processing for efficiency
        const batchSize = 32;
        const embeddings: Float32Array[] = [];
        
        for (let i = 0; i < texts.length; i += batchSize) {
            const batch = texts.slice(i, i + batchSize);
            const batchEmbeddings = await Promise.all(
                batch.map(text => this.embed(text))
            );
            embeddings.push(...batchEmbeddings);
        }
        
        return embeddings;
    }
    
    private meanPool(hiddenStates: Tensor, attentionMask: Tensor): Float32Array {
        // Apply attention mask
        const masked = hiddenStates.mul(attentionMask.unsqueeze(-1));
        
        // Sum along sequence dimension
        const summed = masked.sum(1);
        
        // Divide by sequence length
        const lengths = attentionMask.sum(1).clampMin(1e-9);
        const pooled = summed.div(lengths.unsqueeze(-1));
        
        return pooled.data();
    }
}
```

### Pattern Detection Engine
```typescript
// pattern-detector.ts
class PatternDetector {
    detectPatterns(documents: Document[]): Pattern[] {
        const patterns: Pattern[] = [];
        
        // Detect sequential patterns
        patterns.push(...this.detectSequentialPatterns(documents));
        
        // Detect co-occurrence patterns
        patterns.push(...this.detectCoOccurrencePatterns(documents));
        
        // Detect structural patterns
        patterns.push(...this.detectStructuralPatterns(documents));
        
        // Detect temporal patterns
        patterns.push(...this.detectTemporalPatterns(documents));
        
        return this.rankPatterns(patterns);
    }
    
    private detectCoOccurrencePatterns(documents: Document[]): CoOccurrencePattern[] {
        const coOccurrences = new Map<string, Map<string, number>>();
        
        for (const doc of documents) {
            const concepts = this.extractConcepts(doc);
            
            // Count pairwise co-occurrences
            for (let i = 0; i < concepts.length; i++) {
                for (let j = i + 1; j < concepts.length; j++) {
                    const key = [concepts[i], concepts[j]].sort().join('::');
                    const count = coOccurrences.get(key) || 0;
                    coOccurrences.set(key, count + 1);
                }
            }
        }
        
        // Filter significant patterns
        const patterns: CoOccurrencePattern[] = [];
        const threshold = documents.length * 0.1; // 10% support
        
        for (const [pair, count] of coOccurrences) {
            if (count >= threshold) {
                const [concept1, concept2] = pair.split('::');
                patterns.push({
                    type: 'co-occurrence',
                    concepts: [concept1, concept2],
                    support: count / documents.length,
                    confidence: this.calculateConfidence(concept1, concept2, documents)
                });
            }
        }
        
        return patterns;
    }
    
    private detectTemporalPatterns(documents: Document[]): TemporalPattern[] {
        // Sort documents by creation time
        const sorted = documents.sort((a, b) => 
            a.created.getTime() - b.created.getTime()
        );
        
        const patterns: TemporalPattern[] = [];
        
        // Detect evolution patterns
        const evolutionPatterns = this.detectEvolution(sorted);
        patterns.push(...evolutionPatterns);
        
        // Detect cyclical patterns
        const cyclicalPatterns = this.detectCycles(sorted);
        patterns.push(...cyclicalPatterns);
        
        // Detect burst patterns
        const burstPatterns = this.detectBursts(sorted);
        patterns.push(...burstPatterns);
        
        return patterns;
    }
}
```

### Topic Clustering
```typescript
// topic-clusterer.ts
class TopicClusterer {
    private ldaModel: LDAModel;
    private bertopic: BERTopic;
    
    async clusterDocuments(documents: Document[]): Promise<Cluster[]> {
        // Prepare document texts
        const texts = documents.map(d => d.content);
        
        // Generate embeddings for clustering
        const embeddings = await this.generateEmbeddings(texts);
        
        // Perform hierarchical clustering
        const hierarchical = this.hierarchicalClustering(embeddings);
        
        // Perform topic modeling
        const topics = await this.topicModeling(texts);
        
        // Merge clustering results
        const merged = this.mergeClusters(hierarchical, topics);
        
        // Generate cluster labels
        const labeled = this.labelClusters(merged, documents);
        
        return labeled;
    }
    
    private hierarchicalClustering(embeddings: Float32Array[]): HierarchicalCluster {
        // Build distance matrix
        const distances = this.computeDistanceMatrix(embeddings);
        
        // Perform agglomerative clustering
        const linkage = this.agglomerativeClustering(distances);
        
        // Cut dendrogram at optimal level
        const clusters = this.cutDendrogram(linkage);
        
        return clusters;
    }
    
    private async topicModeling(texts: string[]): Promise<Topic[]> {
        // Use BERTopic for neural topic modeling
        const topics = await this.bertopic.fitTransform(texts);
        
        // Extract topic words
        const topicWords = topics.map(topic => ({
            id: topic.id,
            words: topic.words,
            probability: topic.probability
        }));
        
        return topicWords;
    }
    
    private labelClusters(clusters: Cluster[], documents: Document[]): LabeledCluster[] {
        return clusters.map(cluster => {
            const clusterDocs = cluster.documentIds.map(id => 
                documents.find(d => d.id === id)
            );
            
            // Extract most frequent terms
            const terms = this.extractFrequentTerms(clusterDocs);
            
            // Generate descriptive label
            const label = this.generateLabel(terms);
            
            // Suggest tags based on cluster content
            const tags = this.suggestTags(clusterDocs, terms);
            
            return {
                ...cluster,
                label,
                tags,
                summary: this.generateSummary(clusterDocs)
            };
        });
    }
}
```

### Similarity Calculation
```typescript
// similarity-engine.ts
class SimilarityEngine {
    private index: VectorIndex;
    private metrics: SimilarityMetrics;
    
    calculatePairwiseSimilarity(doc1: Document, doc2: Document): SimilarityScore {
        const scores = {
            semantic: this.semanticSimilarity(doc1, doc2),
            structural: this.structuralSimilarity(doc1, doc2),
            lexical: this.lexicalSimilarity(doc1, doc2),
            conceptual: this.conceptualSimilarity(doc1, doc2)
        };
        
        // Weighted combination
        const combined = this.combineScores(scores);
        
        return {
            overall: combined,
            breakdown: scores,
            confidence: this.calculateConfidence(scores)
        };
    }
    
    private semanticSimilarity(doc1: Document, doc2: Document): number {
        const emb1 = this.getEmbedding(doc1);
        const emb2 = this.getEmbedding(doc2);
        
        // Cosine similarity
        return this.cosineSimilarity(emb1, emb2);
    }
    
    private structuralSimilarity(doc1: Document, doc2: Document): number {
        // Compare document structure
        const struct1 = this.extractStructure(doc1);
        const struct2 = this.extractStructure(doc2);
        
        // Tree edit distance
        const distance = this.treeEditDistance(struct1, struct2);
        
        // Normalize to similarity score
        const maxDistance = Math.max(struct1.size, struct2.size);
        return 1 - (distance / maxDistance);
    }
    
    private conceptualSimilarity(doc1: Document, doc2: Document): number {
        const concepts1 = this.extractConcepts(doc1);
        const concepts2 = this.extractConcepts(doc2);
        
        // Jaccard similarity with concept weights
        const intersection = concepts1.filter(c => 
            concepts2.some(c2 => this.conceptsMatch(c, c2))
        );
        
        const union = [...new Set([...concepts1, ...concepts2])];
        
        return intersection.length / union.length;
    }
}
```

### Manual Override System
```typescript
// override-manager.ts
class OverrideManager {
    private overrides: Map<string, Override>;
    private learningEngine: LearningEngine;
    
    addOverride(suggestion: LinkSuggestion, action: 'accept' | 'reject' | 'modify'): void {
        const override: Override = {
            id: this.generateId(),
            suggestion,
            action,
            timestamp: Date.now(),
            reason: this.captureReason()
        };
        
        this.overrides.set(override.id, override);
        
        // Learn from override
        this.learningEngine.learn(override);
        
        // Update future suggestions
        this.updateSuggestionModel(override);
    }
    
    applyOverrides(suggestions: LinkSuggestion[]): LinkSuggestion[] {
        return suggestions.map(suggestion => {
            const override = this.findOverride(suggestion);
            
            if (override) {
                switch (override.action) {
                    case 'reject':
                        return null;
                    case 'modify':
                        return this.applyModification(suggestion, override);
                    case 'accept':
                        return { ...suggestion, confirmed: true };
                }
            }
            
            // Check if similar override applies
            const similarOverride = this.findSimilarOverride(suggestion);
            if (similarOverride) {
                return this.applySimilarOverride(suggestion, similarOverride);
            }
            
            return suggestion;
        }).filter(Boolean);
    }
    
    private updateSuggestionModel(override: Override): void {
        // Update weights based on user feedback
        if (override.action === 'reject') {
            this.decreaseWeight(override.suggestion.features);
        } else if (override.action === 'accept') {
            this.increaseWeight(override.suggestion.features);
        }
        
        // Retrain model periodically
        if (this.shouldRetrain()) {
            this.retrainModel();
        }
    }
}
```

### Backlink Suggestion UI
```typescript
// backlink-suggester.tsx
const BacklinkSuggester: React.FC = () => {
    const [suggestions, setSuggestions] = useState<LinkSuggestion[]>([]);
    const [filter, setFilter] = useState<FilterOptions>({});
    
    const handleAccept = (suggestion: LinkSuggestion) => {
        // Create backlink
        createBacklink(suggestion);
        
        // Record acceptance
        overrideManager.addOverride(suggestion, 'accept');
        
        // Remove from list
        setSuggestions(prev => prev.filter(s => s.id !== suggestion.id));
    };
    
    const handleReject = (suggestion: LinkSuggestion) => {
        // Record rejection
        overrideManager.addOverride(suggestion, 'reject');
        
        // Remove from list
        setSuggestions(prev => prev.filter(s => s.id !== suggestion.id));
    };
    
    return (\n        <div className=\"backlink-suggester\">\n            <FilterBar onFilterChange={setFilter} />\n            \n            <div className=\"suggestions-list\">\n                {suggestions\n                    .filter(s => matchesFilter(s, filter))\n                    .map(suggestion => (\n                        <SuggestionCard\n                            key={suggestion.id}\n                            suggestion={suggestion}\n                            onAccept={() => handleAccept(suggestion)}\n                            onReject={() => handleReject(suggestion)}\n                            onModify={() => openModifyDialog(suggestion)}\n                        />\n                    ))}\n            </div>\n            \n            <BulkActions\n                suggestions={suggestions}\n                onBulkAccept={handleBulkAccept}\n                onBulkReject={handleBulkReject}\n            />\n        </div>\n    );\n};\n```

### Performance Requirements
- Embedding generation: <200ms per document
- Similarity calculation: <50ms per pair
- Pattern detection: <5s for 100 documents
- Clustering: <10s for 1000 documents
- Suggestion generation: <1s

### Testing
- **Test Location**: `tests/semantic-linking/`
- **Embedding Tests**: `tests/semantic-linking/embeddings/`
- **Pattern Tests**: `tests/semantic-linking/patterns/`
- **Clustering Tests**: `tests/semantic-linking/clustering/`
- **Accuracy Tests**: Verify >80% precision on suggestions

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-31 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
*To be populated during implementation*

### Agent Model Used
*TBD*

### Debug Log References
*TBD*

### Completion Notes List
*TBD*

### File List
*TBD*

## QA Results
*To be populated during QA*