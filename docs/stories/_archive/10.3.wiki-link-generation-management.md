# Story 10.3: Wiki-Link Generation & Management

## Status
Approved

## Story
**As a** user,  
**I want** automatic bi-directional linking between related content,  
**so that** my knowledge network grows organically.

**Estimated Time:** 5-6 hours

## Acceptance Criteria
1. Convert internal references to [[wiki-links]]
2. Automatic concept page creation when referenced
3. Backlink generation for all references
4. Link validation to prevent broken links
5. Alias support for alternative link names
6. Link preview generation for context

## Tasks / Subtasks
- [ ] Implement wiki-link conversion system (AC: 1)
  - [ ] Create WikiLinkProcessor class
  - [ ] Build reference detection patterns
  - [ ] Implement link conversion logic
  - [ ] Handle nested and complex references
  - [ ] Add context-aware linking
  - [ ] Create link formatting options
- [ ] Build automatic concept page creation (AC: 2)
  - [ ] Create ConceptPageManager
  - [ ] Implement page template system
  - [ ] Build concept detection algorithm
  - [ ] Add automatic categorization
  - [ ] Create concept hierarchy
  - [ ] Handle concept conflicts
- [ ] Implement backlink generation (AC: 3)
  - [ ] Create BacklinkTracker system
  - [ ] Build bidirectional link mapping
  - [ ] Implement backlink updates
  - [ ] Add backlink validation
  - [ ] Create backlink queries
  - [ ] Build backlink visualization data
- [ ] Add link validation system (AC: 4)
  - [ ] Create LinkValidator service
  - [ ] Implement broken link detection
  - [ ] Build link health monitoring
  - [ ] Add automatic link repair
  - [ ] Create validation reports
  - [ ] Implement link cleanup
- [ ] Implement alias support (AC: 5)
  - [ ] Create AliasManager system
  - [ ] Build alias resolution
  - [ ] Implement alias suggestions
  - [ ] Add alias validation
  - [ ] Create alias mapping
  - [ ] Handle alias conflicts
- [ ] Build link preview system (AC: 6)
  - [ ] Create PreviewGenerator service
  - [ ] Extract preview content
  - [ ] Build preview formatting
  - [ ] Add image preview support
  - [ ] Create preview caching
  - [ ] Implement preview updates

## Dev Notes

### Wiki-Link Processing Architecture:
```typescript
interface WikiLink {
  originalText: string;
  linkText: string;
  displayText?: string;
  alias?: string;
  isValid: boolean;
  targetExists: boolean;
  preview?: LinkPreview;
}

interface LinkPreview {
  title: string;
  excerpt: string;
  metadata: {
    type: string;
    created: Date;
    tags: string[];
  };
  image?: string;
}

class WikiLinkProcessor {
  private vault: VaultManager;
  private conceptManager: ConceptPageManager;
  
  async processContent(content: string, sourceDocument: Document): Promise<string> {
    // Find potential link targets
    const linkCandidates = this.findLinkCandidates(content);
    
    // Convert to wiki links
    let processedContent = content;
    for (const candidate of linkCandidates) {
      const wikiLink = await this.createWikiLink(candidate, sourceDocument);
      processedContent = processedContent.replace(
        candidate.text, 
        wikiLink.formatted
      );
    }
    
    // Update backlinks
    await this.updateBacklinks(processedContent, sourceDocument);
    
    return processedContent;
  }
  
  private findLinkCandidates(content: string): LinkCandidate[] {
    const candidates: LinkCandidate[] = [];
    
    // Pattern 1: Explicit references ("as discussed in X")
    const explicitRefs = /(?:as discussed in|see|refer to|mentioned in)\s+([A-Z][^.!?]*)/g;
    let match;
    while ((match = explicitRefs.exec(content)) !== null) {
      candidates.push({
        text: match[1].trim(),
        context: match[0],
        type: 'explicit',
        confidence: 0.9
      });
    }
    
    // Pattern 2: Concept mentions (capitalized terms)
    const conceptMentions = /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g;
    while ((match = conceptMentions.exec(content)) !== null) {
      // Filter out common words
      if (!this.isCommonWord(match[1])) {
        candidates.push({
          text: match[1],
          context: this.extractContext(content, match.index),
          type: 'concept',
          confidence: 0.6
        });
      }
    }
    
    // Pattern 3: Technical terms
    const technicalTerms = this.extractTechnicalTerms(content);
    technicalTerms.forEach(term => {
      candidates.push({
        text: term.text,
        context: term.context,
        type: 'technical',
        confidence: 0.7
      });
    });
    
    return this.deduplicateCandidates(candidates);
  }
  
  private async createWikiLink(
    candidate: LinkCandidate, 
    sourceDoc: Document
  ): Promise<FormattedWikiLink> {
    // Check if target exists
    const targetExists = await this.vault.documentExists(candidate.text);
    
    if (!targetExists) {
      // Create concept page if confidence is high enough
      if (candidate.confidence >= 0.8) {
        await this.conceptManager.createConceptPage(candidate.text, sourceDoc);
      }
    }
    
    // Generate wiki link
    const linkText = this.normalizeLinkText(candidate.text);
    const displayText = candidate.text;
    
    // Check for aliases
    const alias = await this.findBestAlias(linkText);
    
    return {
      formatted: alias ? 
        `[[${linkText}|${displayText}]]` : 
        `[[${linkText}]]`,
      target: linkText,
      display: displayText,
      alias: alias?.text,
      confidence: candidate.confidence
    };
  }
}
```

### Concept Page Management:
```typescript
interface ConceptPage {
  id: string;
  title: string;
  type: ConceptType;
  definition: string;
  relatedConcepts: string[];
  sources: SourceReference[];
  examples: string[];
  backlinks: BacklinkReference[];
}

enum ConceptType {
  METHODOLOGY = 'methodology',
  FRAMEWORK = 'framework',
  TECHNIQUE = 'technique',
  PRINCIPLE = 'principle',
  TOOL = 'tool',
  PERSON = 'person',
  ORGANIZATION = 'organization',
  GENERAL = 'general'
}

class ConceptPageManager {
  async createConceptPage(conceptName: string, sourceDoc: Document): Promise<ConceptPage> {
    // Determine concept type
    const conceptType = this.classifyConcept(conceptName, sourceDoc);
    
    // Generate basic definition
    const definition = await this.generateDefinition(conceptName, sourceDoc);
    
    // Find related concepts
    const relatedConcepts = await this.findRelatedConcepts(conceptName);
    
    // Create concept page
    const conceptPage: ConceptPage = {
      id: this.generateConceptId(conceptName),
      title: conceptName,
      type: conceptType,
      definition,
      relatedConcepts,
      sources: [this.createSourceReference(sourceDoc)],
      examples: [],
      backlinks: []
    };
    
    // Generate content
    const content = this.generateConceptContent(conceptPage);
    
    // Save to vault
    await this.vault.saveDocument(conceptPage.id, content, {
      type: 'concept-page',
      conceptType: conceptPage.type,
      autoGenerated: true,
      needsReview: true
    });
    
    return conceptPage;
  }
  
  private generateConceptContent(concept: ConceptPage): string {
    const sections = [];
    
    // Title and metadata
    sections.push(`# ${concept.title}`);
    sections.push('');
    sections.push(`> **Type:** ${concept.type}`);
    sections.push(`> **Status:** Auto-generated concept page`);
    sections.push('');
    
    // Definition
    sections.push('## Definition');
    sections.push(concept.definition);
    sections.push('');
    
    // Related concepts
    if (concept.relatedConcepts.length > 0) {
      sections.push('## Related Concepts');
      concept.relatedConcepts.forEach(related => {
        sections.push(`- [[${related}]]`);
      });
      sections.push('');
    }
    
    // Examples section (placeholder)
    sections.push('## Examples');
    sections.push('*Examples will be added as content is created*');
    sections.push('');
    
    // Sources
    if (concept.sources.length > 0) {
      sections.push('## Sources');
      concept.sources.forEach(source => {
        sections.push(`- [${source.title}](${source.url})`);
      });
      sections.push('');
    }
    
    // Backlinks section (will be updated automatically)
    sections.push('## Mentioned In');
    sections.push('*This section will show documents that reference this concept*');
    
    return sections.join('\n');
  }
  
  private async generateDefinition(conceptName: string, sourceDoc: Document): Promise<string> {
    // Extract context around the concept mention
    const context = this.extractConceptContext(conceptName, sourceDoc.content);
    
    // Use simple heuristics to generate definition
    let definition = `${conceptName} is a concept mentioned in ${sourceDoc.title}.`;
    
    // Look for definition patterns in context
    const definitionPatterns = [
      new RegExp(`${conceptName}\\s+is\\s+([^.!?]+)`, 'i'),
      new RegExp(`${conceptName}\\s*[:-]\\s*([^.!?]+)`, 'i'),
      new RegExp(`${conceptName}\\s+refers to\\s+([^.!?]+)`, 'i')
    ];
    
    for (const pattern of definitionPatterns) {
      const match = pattern.exec(context);
      if (match) {
        definition = `${conceptName} is ${match[1].trim()}.`;
        break;
      }
    }
    
    return definition;
  }
  
  private classifyConcept(conceptName: string, sourceDoc: Document): ConceptType {
    // Simple classification based on keywords
    const name = conceptName.toLowerCase();
    
    if (name.includes('method') || name.includes('technique') || name.includes('approach')) {
      return ConceptType.METHODOLOGY;
    }
    if (name.includes('framework') || name.includes('model')) {
      return ConceptType.FRAMEWORK;
    }
    if (name.includes('principle') || name.includes('law') || name.includes('rule')) {
      return ConceptType.PRINCIPLE;
    }
    if (name.includes('tool') || name.includes('software') || name.includes('platform')) {
      return ConceptType.TOOL;
    }
    
    // Check if it's likely a person name
    if (this.isProbablyPersonName(conceptName)) {
      return ConceptType.PERSON;
    }
    
    // Check if it's an organization
    if (this.isProbablyOrganization(conceptName)) {
      return ConceptType.ORGANIZATION;
    }
    
    return ConceptType.GENERAL;
  }
}
```

### Backlink Management:
```typescript
interface BacklinkReference {
  sourceDocumentId: string;
  sourceTitle: string;
  contextBefore: string;
  contextAfter: string;
  linkText: string;
  createdAt: Date;
}

class BacklinkTracker {
  private backlinkIndex: Map<string, BacklinkReference[]> = new Map();
  
  async updateBacklinks(sourceDoc: Document, wikiLinks: WikiLink[]): Promise<void> {
    // Process each wiki link in the document
    for (const link of wikiLinks) {
      await this.addBacklink(sourceDoc, link);
    }
    
    // Clean up old backlinks for this document
    await this.cleanupOldBacklinks(sourceDoc.id);
  }
  
  private async addBacklink(sourceDoc: Document, link: WikiLink): Promise<void> {
    const backlink: BacklinkReference = {
      sourceDocumentId: sourceDoc.id,
      sourceTitle: sourceDoc.title,
      contextBefore: this.extractContextBefore(sourceDoc.content, link.originalText),
      contextAfter: this.extractContextAfter(sourceDoc.content, link.originalText),
      linkText: link.linkText,
      createdAt: new Date()
    };
    
    // Add to backlink index
    const targetKey = this.normalizeTargetKey(link.linkText);
    if (!this.backlinkIndex.has(targetKey)) {
      this.backlinkIndex.set(targetKey, []);
    }
    this.backlinkIndex.get(targetKey)!.push(backlink);
    
    // Update target document
    await this.updateTargetDocumentBacklinks(link.linkText, backlink);
  }
  
  private async updateTargetDocumentBacklinks(
    targetTitle: string, 
    newBacklink: BacklinkReference
  ): Promise<void> {
    const targetDoc = await this.vault.findDocument(targetTitle);
    if (!targetDoc) return;
    
    // Update backlinks section in target document
    let content = targetDoc.content;
    const backlinksSection = this.findBacklinksSection(content);
    
    if (backlinksSection) {
      // Update existing section
      content = this.updateBacklinksSection(content, newBacklink);
    } else {
      // Add new backlinks section
      content = this.addBacklinksSection(content, [newBacklink]);
    }
    
    await this.vault.updateDocument(targetDoc.id, content);
  }
  
  async getBacklinks(documentTitle: string): Promise<BacklinkReference[]> {
    const key = this.normalizeTargetKey(documentTitle);
    return this.backlinkIndex.get(key) || [];
  }
  
  async generateBacklinksSummary(documentTitle: string): Promise<string> {
    const backlinks = await this.getBacklinks(documentTitle);
    
    if (backlinks.length === 0) {
      return '*No backlinks found*';
    }
    
    const sections = ['## Backlinks', ''];
    
    // Group by source document
    const groupedBacklinks = this.groupBacklinksBySource(backlinks);
    
    Object.entries(groupedBacklinks).forEach(([sourceTitle, links]) => {
      sections.push(`### [[${sourceTitle}]]`);
      links.forEach(link => {
        const context = this.formatBacklinkContext(link);
        sections.push(`- ${context}`);
      });
      sections.push('');
    });
    
    return sections.join('\n');
  }
}
```

### Link Validation System:
```typescript
interface LinkValidationResult {
  link: WikiLink;
  isValid: boolean;
  issues: LinkIssue[];
  suggestions: LinkSuggestion[];
}

interface LinkIssue {
  type: 'broken' | 'ambiguous' | 'circular' | 'orphaned';
  severity: 'error' | 'warning' | 'info';
  message: string;
}

interface LinkSuggestion {
  type: 'rename' | 'merge' | 'create' | 'alias';
  description: string;
  action: string;
}

class LinkValidator {
  async validateLinks(document: Document): Promise<LinkValidationResult[]> {
    const wikiLinks = this.extractWikiLinks(document.content);
    const results: LinkValidationResult[] = [];
    
    for (const link of wikiLinks) {
      const result = await this.validateSingleLink(link, document);
      results.push(result);
    }
    
    return results;
  }
  
  private async validateSingleLink(
    link: WikiLink, 
    sourceDoc: Document
  ): Promise<LinkValidationResult> {
    const issues: LinkIssue[] = [];
    const suggestions: LinkSuggestion[] = [];
    
    // Check if target exists
    const targetExists = await this.vault.documentExists(link.linkText);
    if (!targetExists) {
      issues.push({
        type: 'broken',
        severity: 'error',
        message: `Target document "${link.linkText}" does not exist`
      });
      
      // Suggest similar documents
      const similarDocs = await this.findSimilarDocuments(link.linkText);
      if (similarDocs.length > 0) {
        suggestions.push({
          type: 'rename',
          description: `Did you mean one of these?`,
          action: `Consider linking to: ${similarDocs.slice(0, 3).join(', ')}`
        });
      } else {
        suggestions.push({
          type: 'create',
          description: 'Create missing document',
          action: `Create concept page for "${link.linkText}"`
        });
      }
    }
    
    // Check for circular references
    if (await this.hasCircularReference(link, sourceDoc)) {
      issues.push({
        type: 'circular',
        severity: 'warning',
        message: 'Potential circular reference detected'
      });
    }
    
    // Check for ambiguous links
    const ambiguousTargets = await this.findAmbiguousTargets(link.linkText);
    if (ambiguousTargets.length > 1) {
      issues.push({
        type: 'ambiguous',
        severity: 'warning',
        message: `Multiple documents match "${link.linkText}"`
      });
      
      suggestions.push({
        type: 'alias',
        description: 'Use more specific link',
        action: `Consider using: ${ambiguousTargets.join(' or ')}`
      });
    }
    
    return {
      link,
      isValid: issues.filter(i => i.severity === 'error').length === 0,
      issues,
      suggestions
    };
  }
  
  async repairBrokenLinks(document: Document): Promise<Document> {
    const validationResults = await this.validateLinks(document);
    let repairedContent = document.content;
    
    for (const result of validationResults) {
      if (!result.isValid) {
        const repair = await this.suggestLinkRepair(result);
        if (repair) {
          repairedContent = repairedContent.replace(
            result.link.originalText,
            repair.replacement
          );
        }
      }
    }
    
    return { ...document, content: repairedContent };
  }
}
```

### Alias Management:
```typescript
interface DocumentAlias {
  canonical: string;     // The main document title
  aliases: string[];     // Alternative names
  confidence: number;    // How confident we are about the alias
  createdBy: 'auto' | 'user';
}

class AliasManager {
  private aliasMap: Map<string, DocumentAlias> = new Map();
  
  async createAlias(canonical: string, alias: string, confidence: number = 1.0): Promise<void> {
    const key = this.normalizeKey(canonical);
    
    if (!this.aliasMap.has(key)) {
      this.aliasMap.set(key, {
        canonical,
        aliases: [],
        confidence: 1.0,
        createdBy: 'user'
      });
    }
    
    const aliasEntry = this.aliasMap.get(key)!;
    if (!aliasEntry.aliases.includes(alias)) {
      aliasEntry.aliases.push(alias);
    }
  }
  
  async resolveAlias(linkText: string): Promise<string> {
    // First, check if it's a direct match
    if (await this.vault.documentExists(linkText)) {
      return linkText;
    }
    
    // Check aliases
    for (const [, aliasEntry] of this.aliasMap) {
      if (aliasEntry.aliases.includes(linkText)) {
        return aliasEntry.canonical;
      }
    }
    
    // Try fuzzy matching
    const fuzzyMatch = await this.findFuzzyMatch(linkText);
    if (fuzzyMatch && fuzzyMatch.confidence > 0.8) {
      // Automatically create alias for future use
      await this.createAlias(fuzzyMatch.canonical, linkText, fuzzyMatch.confidence);
      return fuzzyMatch.canonical;
    }
    
    return linkText; // Return original if no match found
  }
  
  async suggestAliases(documentTitle: string): Promise<string[]> {
    const suggestions: string[] = [];
    
    // Common abbreviations
    const abbreviation = this.generateAbbreviation(documentTitle);
    if (abbreviation && abbreviation !== documentTitle) {
      suggestions.push(abbreviation);
    }
    
    // Alternative formats
    const alternatives = this.generateAlternativeFormats(documentTitle);
    suggestions.push(...alternatives);
    
    // Extract from content (if document exists)
    const document = await this.vault.findDocument(documentTitle);
    if (document) {
      const contentAliases = this.extractAliasesFromContent(document.content, documentTitle);
      suggestions.push(...contentAliases);
    }
    
    return this.deduplicateAndRankSuggestions(suggestions);
  }
  
  private generateAbbreviation(title: string): string {
    // Simple abbreviation logic
    const words = title.split(' ').filter(word => word.length > 2);
    if (words.length > 1) {
      return words.map(word => word[0].toUpperCase()).join('');
    }
    return '';
  }
  
  private extractAliasesFromContent(content: string, mainTitle: string): string[] {
    const aliases: string[] = [];
    
    // Look for "also known as", "aka", etc.
    const akaPatterns = [
      /also known as ([^.!?]+)/gi,
      /\(aka ([^)]+)\)/gi,
      /also called ([^.!?]+)/gi
    ];
    
    akaPatterns.forEach(pattern => {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        aliases.push(match[1].trim());
      }
    });
    
    return aliases;
  }
}
```

### Link Preview System:
```typescript
class PreviewGenerator {
  async generatePreview(linkTarget: string): Promise<LinkPreview | null> {
    const document = await this.vault.findDocument(linkTarget);
    if (!document) return null;
    
    return {
      title: document.title,
      excerpt: this.generateExcerpt(document.content),
      metadata: {
        type: document.type,
        created: document.createdAt,
        tags: document.tags || []
      },
      image: await this.extractImage(document.content)
    };
  }
  
  private generateExcerpt(content: string, maxLength: number = 200): string {
    // Remove frontmatter
    const withoutFrontmatter = content.replace(/^---[\s\S]*?---\n/, '');
    
    // Remove markdown formatting
    const plainText = withoutFrontmatter
      .replace(/#+\s/g, '') // Headers
      .replace(/\*\*(.*?)\*\*/g, '$1') // Bold
      .replace(/\*(.*?)\*/g, '$1') // Italic
      .replace(/\[(.*?)\]\(.*?\)/g, '$1') // Links
      .replace(/```[\s\S]*?```/g, '[code block]') // Code blocks
      .trim();
    
    // Get first paragraph or sentence
    const firstParagraph = plainText.split('\n\n')[0];
    
    if (firstParagraph.length <= maxLength) {
      return firstParagraph;
    }
    
    // Truncate at word boundary
    const truncated = firstParagraph.substring(0, maxLength);
    const lastSpace = truncated.lastIndexOf(' ');
    
    return truncated.substring(0, lastSpace) + '...';
  }
  
  private async extractImage(content: string): Promise<string | undefined> {
    // Look for image references
    const imageRegex = /!\[.*?\]\((.*?)\)/;
    const match = imageRegex.exec(content);
    
    if (match && match[1]) {
      return match[1];
    }
    
    return undefined;
  }
}
```

### Testing
**Testing Framework:** Jest
**Test File Location:** `.flcm-core/tests/obsidian/links/`

**Unit Tests:**
- Wiki-link pattern detection and conversion
- Concept page generation accuracy
- Backlink tracking and updates
- Link validation and repair
- Alias resolution and suggestions
- Preview generation quality

**Integration Tests:**
- End-to-end link processing workflow
- Multi-document backlink consistency
- Link validation across vault
- Alias system functionality
- Preview generation and caching

**Test Scenarios:**
```
tests/fixtures/links/
├── valid-links/
├── broken-links/
├── circular-references/
├── ambiguous-targets/
├── alias-examples/
└── preview-samples/
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_