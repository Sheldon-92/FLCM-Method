# Story 2.0-2.6: Daily Learning Summaries

## Status
Draft

## Story
**As a** reflective practitioner,  
**I want** automated summaries of my learning,  
**so that** I can review and consolidate my insights.

## Acceptance Criteria
1. Daily note generation with learning summary
2. Key insights from the day highlighted
3. Progress metrics included
4. Links to all created content
5. Reflection prompts for deeper thinking
6. Weekly rollup summaries

## Tasks / Subtasks
- [ ] Task 1: Build daily note generator (AC: 1)
  - [ ] Subtask 1.1: Create daily note template system
  - [ ] Subtask 1.2: Implement scheduled generation
  - [ ] Subtask 1.3: Add customizable note location
  - [ ] Subtask 1.4: Build conflict resolution for existing notes

- [ ] Task 2: Extract key insights (AC: 2)
  - [ ] Subtask 2.1: Identify today's insights
  - [ ] Subtask 2.2: Rank insights by importance
  - [ ] Subtask 2.3: Extract key quotes
  - [ ] Subtask 2.4: Create insight summaries

- [ ] Task 3: Include progress metrics (AC: 3)
  - [ ] Subtask 3.1: Calculate daily statistics
  - [ ] Subtask 3.2: Compare to historical averages
  - [ ] Subtask 3.3: Identify achievements
  - [ ] Subtask 3.4: Track streak information

- [ ] Task 4: Create content linking (AC: 4)
  - [ ] Subtask 4.1: Collect all created documents
  - [ ] Subtask 4.2: Organize by type and framework
  - [ ] Subtask 4.3: Generate link previews
  - [ ] Subtask 4.4: Add navigation structure

- [ ] Task 5: Generate reflection prompts (AC: 5)
  - [ ] Subtask 5.1: Create prompt bank
  - [ ] Subtask 5.2: Select contextual prompts
  - [ ] Subtask 5.3: Personalize based on patterns
  - [ ] Subtask 5.4: Track prompt responses

- [ ] Task 6: Build weekly rollups (AC: 6)
  - [ ] Subtask 6.1: Aggregate daily summaries
  - [ ] Subtask 6.2: Identify weekly themes
  - [ ] Subtask 6.3: Create trend visualizations
  - [ ] Subtask 6.4: Generate weekly insights

## Dev Notes

### Daily Summary Architecture
```typescript
// daily-summary-generator.ts
class DailySummaryGenerator {
    private vault: Vault;
    private analyzer: ContentAnalyzer;
    private metrics: MetricsCollector;
    private scheduler: CronScheduler;
    
    constructor() {
        // Schedule daily generation
        this.scheduler.schedule('0 23 * * *', () => this.generateDailySummary());
    }
    
    async generateDailySummary(date: Date = new Date()): Promise<void> {
        // Collect today's data
        const todayData = await this.collectTodayData(date);
        
        // Generate summary content
        const summary = await this.createSummary(todayData);
        
        // Create or update daily note
        const notePath = this.getDailyNotePath(date);
        await this.createOrUpdateNote(notePath, summary);
        
        // Trigger weekly rollup if needed
        if (this.isEndOfWeek(date)) {
            await this.generateWeeklyRollup(date);
        }
    }
    
    private async collectTodayData(date: Date): Promise<DailyData> {
        const startOfDay = new Date(date);
        startOfDay.setHours(0, 0, 0, 0);
        const endOfDay = new Date(date);
        endOfDay.setHours(23, 59, 59, 999);
        
        return {
            documents: await this.getDocumentsCreatedToday(startOfDay, endOfDay),
            insights: await this.getInsightsToday(startOfDay, endOfDay),
            frameworks: await this.getFrameworksUsedToday(startOfDay, endOfDay),
            sessions: await this.getSessionsToday(startOfDay, endOfDay),
            metrics: await this.metrics.getDailyMetrics(date)
        };
    }
}
```

### Daily Note Template
```markdown
---
date: {{date}}
type: daily-summary
tags:
  - flcm/daily
  - flcm/summary
---

# Daily Learning Summary - {{formatted_date}}

## 📊 Today's Metrics
- **Documents Created**: {{document_count}}
- **Insights Generated**: {{insight_count}}
- **Frameworks Used**: {{frameworks_list}}
- **Time Invested**: {{time_spent}}
- **Learning Streak**: {{streak_days}} days

## 🌟 Key Insights

{{#each insights}}
### {{this.title}}
> {{this.summary}}

*Framework: {{this.framework}} | Depth: {{this.depth}}*
[[{{this.link}}|View Full Insight →]]

{{/each}}

## 📝 Content Created Today

### Morning Session ({{morning_time}})
{{#each morning_content}}
- [[{{this.link}}|{{this.title}}]] - {{this.type}}
{{/each}}

### Afternoon Session ({{afternoon_time}})
{{#each afternoon_content}}
- [[{{this.link}}|{{this.title}}]] - {{this.type}}
{{/each}}

### Evening Session ({{evening_time}})
{{#each evening_content}}
- [[{{this.link}}|{{this.title}}]] - {{this.type}}
{{/each}}

## 📈 Progress Analysis

### Depth Progression
{{depth_chart}}

Your average insight depth today was **{{avg_depth}}**, {{depth_comparison}} yesterday's {{yesterday_depth}}.

### Framework Effectiveness
{{#each framework_stats}}
- **{{this.name}}**: {{this.insights}} insights, {{this.effectiveness}}% effective
{{/each}}

## 💭 Reflection Prompts

{{#each prompts}}
{{@index}}. {{this}}
   > _[Your reflection here]_
   
{{/each}}

## 🔗 Connections Made
New connections discovered today:
{{#each connections}}
- [[{{this.source}}]] ↔ [[{{this.target}}]] ({{this.strength}}% similarity)
{{/each}}

## 🎯 Tomorrow's Focus
Based on today's learning patterns, consider:
{{#each recommendations}}
- {{this}}
{{/each}}

---
*Generated at {{generation_time}} by FLCM 2.0*
```

### Insight Extraction
```typescript
// insight-extractor.ts
class InsightExtractor {
    async extractKeyInsights(documents: Document[]): Promise<Insight[]> {
        const insights: Insight[] = [];
        
        for (const doc of documents) {
            // Extract insights based on document type
            if (this.isInsightDocument(doc)) {
                insights.push(await this.processInsightDocument(doc));
            } else {
                // Extract insights from regular content
                const extracted = await this.extractFromContent(doc);
                insights.push(...extracted);
            }
        }
        
        // Rank insights by importance
        const ranked = this.rankInsights(insights);
        
        // Return top insights
        return ranked.slice(0, 5);
    }
    
    private rankInsights(insights: Insight[]): Insight[] {
        return insights.sort((a, b) => {
            const scoreA = this.calculateImportance(a);
            const scoreB = this.calculateImportance(b);
            return scoreB - scoreA;
        });
    }
    
    private calculateImportance(insight: Insight): number {
        let score = 0;
        
        // Depth contributes to importance
        score += insight.depth * 20;
        
        // Connections increase importance
        score += insight.connections.length * 10;
        
        // Evidence quality
        score += this.assessEvidenceQuality(insight.evidence) * 15;
        
        // Novelty
        score += this.assessNovelty(insight) * 25;
        
        // User engagement (if tracked)
        score += insight.engagement * 10;
        
        return score;
    }
    
    private async extractFromContent(doc: Document): Promise<Insight[]> {
        const insights: Insight[] = [];
        
        // Look for insight markers
        const markers = [
            /Key insight:/gi,
            /I realized that/gi,
            /This means that/gi,
            /The pattern here is/gi,
            /What's interesting is/gi
        ];
        
        for (const marker of markers) {
            const matches = doc.content.matchAll(marker);
            for (const match of matches) {
                const insight = this.extractInsightFromContext(
                    doc.content,
                    match.index
                );
                if (insight) {
                    insights.push(insight);
                }
            }
        }
        
        return insights;
    }
}
```

### Progress Metrics Calculator
```typescript
// progress-metrics.ts
class ProgressMetricsCalculator {
    calculateDailyMetrics(data: DailyData): DailyMetrics {
        return {
            documentCount: data.documents.length,
            insightCount: data.insights.length,
            frameworksUsed: this.countUniqueFrameworks(data),
            timeSpent: this.calculateTimeSpent(data.sessions),
            avgInsightDepth: this.calculateAverageDepth(data.insights),
            learningVelocity: this.calculateVelocity(data),
            streak: this.calculateStreak(data),
            achievements: this.checkAchievements(data)
        };
    }
    
    compareToHistory(current: DailyMetrics, history: DailyMetrics[]): Comparison {
        const avgHistorical = this.calculateHistoricalAverages(history);
        
        return {
            documentGrowth: this.percentChange(
                current.documentCount,
                avgHistorical.documentCount
            ),
            insightGrowth: this.percentChange(
                current.insightCount,
                avgHistorical.insightCount
            ),
            depthImprovement: current.avgInsightDepth - avgHistorical.avgInsightDepth,
            velocityChange: this.percentChange(
                current.learningVelocity,
                avgHistorical.learningVelocity
            ),
            trend: this.calculateTrend(history.concat(current))
        };
    }
    
    private calculateStreak(data: DailyData): StreakInfo {
        // Query historical data
        const previousDays = this.getPreviousDays(30);
        let streak = 0;
        
        for (const day of previousDays.reverse()) {
            if (this.hasActivity(day)) {
                streak++;
            } else {
                break;
            }
        }
        
        return {
            current: streak,
            longest: this.getLongestStreak(),
            message: this.getStreakMessage(streak)
        };
    }
}
```

### Reflection Prompt Generator
```typescript
// reflection-prompts.ts
class ReflectionPromptGenerator {
    private promptBank = {
        general: [
            "What surprised you most in today's learning?",
            "How has your understanding evolved today?",
            "What questions emerged from today's exploration?",
            "What would you like to explore deeper tomorrow?"
        ],
        insight_focused: [
            "Which insight from today will impact your future work?",
            "How do today's insights connect to your broader goals?",
            "What patterns are emerging across your recent insights?"
        ],
        framework_focused: [
            "Which framework was most effective today and why?",
            "How might you combine frameworks for deeper analysis?",
            "What new perspective did the {{framework}} framework provide?"
        ],
        growth_focused: [
            "How have you grown as a thinker today?",
            "What learning strategy worked best today?",
            "What challenge did you overcome in your learning?"
        ]
    };
    
    generatePrompts(data: DailyData): string[] {
        const prompts: string[] = [];
        
        // Select prompts based on today's activity
        if (data.insights.length > 3) {
            prompts.push(this.selectRandom(this.promptBank.insight_focused));
        }
        
        if (data.frameworks.length > 1) {
            const frameworkPrompt = this.selectRandom(this.promptBank.framework_focused);
            prompts.push(frameworkPrompt.replace('{{framework}}', data.frameworks[0].name));
        }
        
        // Always include a general prompt
        prompts.push(this.selectRandom(this.promptBank.general));
        
        // Add personalized prompt based on patterns
        const personalized = this.generatePersonalizedPrompt(data);
        if (personalized) {
            prompts.push(personalized);
        }
        
        return prompts.slice(0, 3); // Return top 3 prompts
    }
    
    private generatePersonalizedPrompt(data: DailyData): string {
        // Analyze patterns in user's learning
        const patterns = this.analyzePatterns(data);
        
        if (patterns.depthIncreasing) {
            return "Your insights are getting deeper. What enabled this progression?";
        }
        
        if (patterns.newFramework) {
            return `You tried ${patterns.newFramework} for the first time. How did it compare to your usual approaches?`;
        }
        
        if (patterns.connectionRich) {
            return "You made many connections today. Which connection surprised you most?";
        }
        
        return null;
    }
}
```

### Weekly Rollup Generator
```typescript
// weekly-rollup.ts
class WeeklyRollupGenerator {
    async generateWeeklyRollup(endDate: Date): Promise<void> {
        const weekData = await this.collectWeekData(endDate);
        const rollup = await this.createRollup(weekData);
        
        const notePath = this.getWeeklyNotePath(endDate);
        await this.createNote(notePath, rollup);
    }
    
    private async createRollup(weekData: WeekData): Promise<string> {
        const template = `# Weekly Learning Rollup - Week of {{week_start}}

## 📊 Week at a Glance
- **Total Documents**: {{total_documents}}
- **Total Insights**: {{total_insights}}
- **Frameworks Explored**: {{framework_count}}
- **Time Invested**: {{total_time}}
- **Most Productive Day**: {{best_day}}

## 🎯 Key Themes
{{#each themes}}
### {{this.name}}
*Appeared in {{this.count}} documents*

Key insights:
{{#each this.insights}}
- {{this}}
{{/each}}
{{/each}}

## 📈 Progress Trends
### Depth Evolution
{{depth_chart}}

Your insight depth {{depth_trend}} throughout the week.

### Learning Velocity
{{velocity_chart}}

Peak learning occurred on {{peak_day}} with {{peak_insights}} insights.

## 🏆 Weekly Achievements
{{#each achievements}}
- ✅ {{this}}
{{/each}}

## 💡 Top 5 Insights of the Week
{{#each top_insights}}
{{@index}}. **{{this.title}}**
   > {{this.summary}}
   
   *Created on {{this.date}} using {{this.framework}}*
{{/each}}

## 🔄 Patterns Identified
{{#each patterns}}
- **{{this.type}}**: {{this.description}}
{{/each}}

## 📚 Knowledge Graph Update
- **New Nodes**: {{new_nodes}}
- **New Connections**: {{new_connections}}
- **Strongest Cluster**: {{strongest_cluster}}

## 🎯 Next Week's Recommendations
Based on this week's learning patterns:
{{#each recommendations}}
1. {{this}}
{{/each}}

## 📝 Weekly Reflection
*Space for your weekly reflection*

---
*Generated on {{generation_date}} by FLCM 2.0*
`;
        
        return this.processTemplate(template, weekData);
    }
    
    private identifyWeeklyThemes(documents: Document[]): Theme[] {
        // Use topic modeling to identify themes
        const topics = this.topicModeler.extractTopics(documents);
        
        return topics.map(topic => ({
            name: topic.label,
            count: topic.documents.length,
            insights: this.extractThemeInsights(topic),
            strength: topic.coherence
        }));
    }
    
    private analyzeProgressTrends(weekData: WeekData): TrendAnalysis {
        const dailyMetrics = weekData.days.map(d => d.metrics);
        
        return {
            depthTrend: this.calculateTrend(dailyMetrics.map(m => m.avgDepth)),
            velocityTrend: this.calculateTrend(dailyMetrics.map(m => m.velocity)),
            consistencyScore: this.calculateConsistency(dailyMetrics),
            growthRate: this.calculateGrowthRate(dailyMetrics)
        };
    }
}
```

### Scheduling System
```typescript
// scheduler.ts
class SummaryScheduler {
    private cron: CronJob;
    private settings: SchedulerSettings;
    
    initialize(settings: SchedulerSettings) {
        this.settings = settings;
        
        // Schedule daily summary
        this.cron.schedule(settings.dailyTime, async () => {
            await this.generateDailySummary();
        });
        
        // Schedule weekly rollup
        this.cron.schedule(settings.weeklyTime, async () => {
            await this.generateWeeklyRollup();
        });
        
        // Allow manual triggers
        this.registerCommands();
    }
    
    private registerCommands() {
        this.app.commands.addCommand({
            id: 'flcm-generate-daily-summary',
            name: 'FLCM: Generate Daily Summary',
            callback: () => this.generateDailySummary(new Date())
        });
        
        this.app.commands.addCommand({
            id: 'flcm-generate-weekly-rollup',
            name: 'FLCM: Generate Weekly Rollup',
            callback: () => this.generateWeeklyRollup(new Date())
        });
    }
}
```

### Performance Requirements
- Daily summary generation: <3s
- Insight extraction: <1s per document
- Metric calculation: <500ms
- Weekly rollup: <5s

### Testing
- **Test Location**: `tests/daily-summaries/`
- **Generation Tests**: `tests/daily-summaries/generation/`
- **Extraction Tests**: `tests/daily-summaries/insights/`
- **Rollup Tests**: `tests/daily-summaries/weekly/`
- **Schedule Tests**: Verify cron execution

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-31 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
*To be populated during implementation*

### Agent Model Used
*TBD*

### Debug Log References
*TBD*

### Completion Notes List
*TBD*

### File List
*TBD*

## QA Results
*To be populated during QA*