# Story 2.0-2.3: Learning Progress Tracker

## Status
Draft

## Story
**As a** lifelong learner,  
**I want** to track my growth and understanding over time,  
**so that** I can see how my thinking evolves.

## Acceptance Criteria
1. Dashboard showing framework usage statistics
2. Insight depth progression over time
3. Content quality metrics trending
4. Learning velocity calculations
5. Weekly/monthly progress reports
6. Exportable learning analytics

## Tasks / Subtasks
- [ ] Task 1: Build metrics collection system (AC: 1)
  - [ ] Subtask 1.1: Track framework usage frequency
  - [ ] Subtask 1.2: Record framework completion rates
  - [ ] Subtask 1.3: Measure time spent per framework
  - [ ] Subtask 1.4: Calculate framework effectiveness scores

- [ ] Task 2: Implement depth tracking (AC: 2)
  - [ ] Subtask 2.1: Define insight depth metrics
  - [ ] Subtask 2.2: Create progression algorithms
  - [ ] Subtask 2.3: Build depth visualization
  - [ ] Subtask 2.4: Add milestone detection

- [ ] Task 3: Create quality metrics (AC: 3)
  - [ ] Subtask 3.1: Define content quality indicators
  - [ ] Subtask 3.2: Implement quality scoring
  - [ ] Subtask 3.3: Build trend analysis
  - [ ] Subtask 3.4: Add peer comparison (optional)

- [ ] Task 4: Calculate learning velocity (AC: 4)
  - [ ] Subtask 4.1: Define velocity metrics
  - [ ] Subtask 4.2: Implement rate calculations
  - [ ] Subtask 4.3: Create acceleration tracking
  - [ ] Subtask 4.4: Build predictive models

- [ ] Task 5: Generate progress reports (AC: 5)
  - [ ] Subtask 5.1: Design report templates
  - [ ] Subtask 5.2: Implement weekly summaries
  - [ ] Subtask 5.3: Create monthly deep dives
  - [ ] Subtask 5.4: Add custom report builder

- [ ] Task 6: Build export system (AC: 6)
  - [ ] Subtask 6.1: Create CSV export
  - [ ] Subtask 6.2: Implement JSON analytics export
  - [ ] Subtask 6.3: Build PDF report generation
  - [ ] Subtask 6.4: Add API for external tools

## Dev Notes

### Learning Metrics Architecture
```typescript
// learning-tracker.ts
interface LearningMetrics {
    userId: string;
    timeRange: DateRange;
    frameworks: FrameworkUsage[];
    insights: InsightProgression;
    content: ContentQuality;
    velocity: LearningVelocity;
    milestones: Milestone[];
}

class LearningProgressTracker {
    private metricsStore: MetricsDatabase;
    private analyzer: ProgressAnalyzer;
    
    async trackSession(session: LearningSession) {
        const metrics = {
            timestamp: Date.now(),
            framework: session.framework,
            duration: session.endTime - session.startTime,
            insightCount: session.insights.length,
            insightDepth: this.calculateDepth(session.insights),
            contentQuality: this.assessQuality(session.content),
            completionRate: session.completedSteps / session.totalSteps
        };
        
        await this.metricsStore.save(metrics);
        await this.checkMilestones(session.userId, metrics);
    }
    
    async generateDashboard(userId: string): Promise<Dashboard> {
        const metrics = await this.metricsStore.getMetrics(userId);
        
        return {
            frameworkStats: this.calculateFrameworkStats(metrics),
            progressionChart: this.buildProgressionChart(metrics),
            velocityGauge: this.calculateVelocity(metrics),
            qualityTrend: this.analyzeQualityTrend(metrics),
            achievements: this.getAchievements(userId)
        };
    }
}
```

### Framework Usage Statistics
```typescript
class FrameworkAnalyzer {
    calculateUsageStats(sessions: LearningSession[]): FrameworkStats {
        const stats = new Map<string, FrameworkUsage>();
        
        for (const session of sessions) {
            const existing = stats.get(session.framework) || {
                name: session.framework,
                usageCount: 0,
                totalTime: 0,
                avgCompletionRate: 0,
                avgInsightDepth: 0,
                effectiveness: 0
            };
            
            existing.usageCount++;
            existing.totalTime += session.duration;
            existing.avgCompletionRate = this.updateAverage(
                existing.avgCompletionRate,
                session.completionRate,
                existing.usageCount
            );
            
            stats.set(session.framework, existing);
        }
        
        // Calculate effectiveness scores
        for (const [framework, usage] of stats) {
            usage.effectiveness = this.calculateEffectiveness(usage);
        }
        
        return stats;
    }
    
    calculateEffectiveness(usage: FrameworkUsage): number {
        // Weighted formula considering multiple factors
        return (
            usage.avgCompletionRate * 0.3 +
            usage.avgInsightDepth * 0.4 +
            Math.min(usage.usageCount / 10, 1) * 0.3
        );
    }
}
```

### Insight Depth Progression
```typescript
class InsightDepthAnalyzer {
    levels = [
        { level: 1, name: 'Surface', minScore: 0 },
        { level: 2, name: 'Shallow', minScore: 20 },
        { level: 3, name: 'Moderate', minScore: 40 },
        { level: 4, name: 'Deep', minScore: 60 },
        { level: 5, name: 'Profound', minScore: 80 }
    ];
    
    calculateDepth(insight: Insight): number {
        let score = 0;
        
        // Factors contributing to depth
        score += this.analyzeComplexity(insight.content) * 20;
        score += this.countConnections(insight.links) * 10;
        score += this.assessOriginality(insight.content) * 25;
        score += this.evaluateEvidence(insight.evidence) * 20;
        score += this.measureSynthesis(insight.synthesis) * 25;
        
        return Math.min(score, 100);
    }
    
    trackProgression(insights: Insight[]): ProgressionData {
        const timeline = insights.map(insight => ({
            timestamp: insight.created,
            depth: this.calculateDepth(insight),
            level: this.getLevel(this.calculateDepth(insight))
        }));
        
        // Calculate trend
        const trend = this.calculateTrend(timeline);
        
        // Identify breakthrough moments
        const breakthroughs = this.identifyBreakthroughs(timeline);
        
        return {
            timeline,
            trend,
            breakthroughs,
            currentLevel: timeline[timeline.length - 1]?.level || 1
        };
    }
}
```

### Content Quality Metrics
```typescript
class ContentQualityAnalyzer {
    assessQuality(content: Content): QualityScore {
        const metrics = {
            clarity: this.assessClarity(content.text),
            coherence: this.assessCoherence(content.structure),
            originality: this.assessOriginality(content.text),
            evidence: this.assessEvidence(content.sources),
            engagement: this.assessEngagement(content.style),
            completeness: this.assessCompleteness(content)
        };
        
        const overallScore = this.calculateOverallScore(metrics);
        
        return {
            score: overallScore,
            metrics,
            strengths: this.identifyStrengths(metrics),
            improvements: this.suggestImprovements(metrics)
        };
    }
    
    analyzeQualityTrend(contents: Content[]): TrendAnalysis {
        const scores = contents.map(c => this.assessQuality(c));
        
        return {
            trend: this.calculateTrend(scores),
            avgScore: scores.reduce((a, b) => a + b.score, 0) / scores.length,
            improvement: scores[scores.length - 1].score - scores[0].score,
            consistency: this.calculateConsistency(scores)
        };
    }
}
```

### Learning Velocity Calculator
```typescript
class LearningVelocityCalculator {
    calculateVelocity(sessions: LearningSession[]): VelocityMetrics {
        // Group sessions by time period
        const periods = this.groupByPeriod(sessions, 'week');
        
        const velocities = periods.map(period => ({
            period: period.start,
            insightsPerHour: period.insights.length / period.totalHours,
            frameworksCompleted: period.completedFrameworks,
            depthProgression: period.avgDepth - period.previousAvgDepth,
            contentProduced: period.contentCount
        }));
        
        return {
            current: velocities[velocities.length - 1],
            trend: this.calculateTrend(velocities),
            acceleration: this.calculateAcceleration(velocities),
            prediction: this.predictFuture(velocities)
        };
    }
    
    predictFuture(velocities: Velocity[]): Prediction {
        // Use simple linear regression for prediction
        const regression = this.linearRegression(velocities);
        
        return {
            nextWeek: this.extrapolate(regression, 1),
            nextMonth: this.extrapolate(regression, 4),
            milestoneETA: this.estimateMilestoneCompletion(regression)
        };
    }
}
```

### Progress Report Generation
```typescript
class ProgressReportGenerator {
    async generateWeeklyReport(userId: string): Promise<Report> {
        const weekData = await this.getWeekData(userId);
        
        return {
            title: `Weekly Learning Progress`,
            period: weekData.period,
            highlights: [
                `Created ${weekData.insightCount} insights`,
                `Used ${weekData.frameworksUsed.length} frameworks`,
                `Average depth increased by ${weekData.depthIncrease}%`,
                `${weekData.milestonesAchieved} milestones achieved`
            ],
            metrics: {
                frameworkUsage: weekData.frameworkStats,
                insightProgression: weekData.insightChart,
                contentQuality: weekData.qualityMetrics,
                timeInvested: weekData.totalTime
            },
            recommendations: this.generateRecommendations(weekData)
        };
    }
    
    generateRecommendations(data: WeekData): string[] {
        const recommendations = [];
        
        // Framework diversity
        if (data.frameworksUsed.length < 3) {
            recommendations.push('Try exploring different frameworks for diverse perspectives');
        }
        
        // Depth progression
        if (data.depthIncrease < 5) {
            recommendations.push('Focus on deeper analysis using Socratic questioning');
        }
        
        // Consistency
        if (data.sessionGaps > 3) {
            recommendations.push('Consider more regular learning sessions for better retention');
        }
        
        return recommendations;
    }
}
```

### Dashboard UI Components
```typescript
// dashboard-components.tsx
const LearningDashboard: React.FC = () => {
    const [metrics, setMetrics] = useState<LearningMetrics>();
    const [timeRange, setTimeRange] = useState<DateRange>('last30days');
    
    return (
        <div className="learning-dashboard">
            <FrameworkUsageChart data={metrics?.frameworks} />
            <InsightDepthProgression data={metrics?.insights} />
            <ContentQualityTrend data={metrics?.content} />
            <VelocityGauge current={metrics?.velocity.current} />
            <MilestoneTimeline milestones={metrics?.milestones} />
            <ProgressReport timeRange={timeRange} />
        </div>
    );
};
```

### Performance Requirements
- Dashboard load: <2s
- Metric calculation: <500ms per metric
- Report generation: <3s
- Export: <5s for full history

### Testing
- **Test Location**: `tests/learning-progress/`
- **Metrics Tests**: `tests/learning-progress/metrics/`
- **Report Tests**: `tests/learning-progress/reports/`
- **Performance Tests**: Test with 1 year of daily usage data
- **Accuracy Tests**: Verify metric calculations

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-31 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
*To be populated during implementation*

### Agent Model Used
*TBD*

### Debug Log References
*TBD*

### Completion Notes List
*TBD*

### File List
*TBD*

## QA Results
*To be populated during QA*