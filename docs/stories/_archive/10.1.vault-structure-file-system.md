# Story 10.1: Vault Structure & File System Integration

## Status
Approved

## Story
**As a** user,  
**I want** FLCM to automatically organize content in my Obsidian vault,  
**so that** my knowledge is systematically stored and easily navigable.

**Estimated Time:** 4-5 hours

## Acceptance Criteria
1. Folder structure implementation (Inbox, Learning, Creation, Published, Knowledge-Base)
2. File naming convention enforcement ([type]-[date]-[title-slug].md)
3. Automatic file placement based on document type and status
4. Path configuration for vault location
5. Cross-platform path compatibility (Windows/Mac/Linux)
6. Folder creation with proper permissions

## Tasks / Subtasks
- [ ] Implement folder structure system (AC: 1)
  - [ ] Create VaultStructureManager class
  - [ ] Define standard folder hierarchy
  - [ ] Implement folder creation logic
  - [ ] Add folder description files
  - [ ] Create folder templates
  - [ ] Handle existing folder conflicts
- [ ] Build file naming convention system (AC: 2)
  - [ ] Create FileNameGenerator class
  - [ ] Define naming patterns by document type
  - [ ] Implement slug generation from titles
  - [ ] Add date formatting options
  - [ ] Handle special characters and Unicode
  - [ ] Prevent filename conflicts
- [ ] Create automatic file placement (AC: 3)
  - [ ] Implement DocumentClassifier
  - [ ] Build placement rules engine
  - [ ] Add status-based routing
  - [ ] Create workflow state mapping
  - [ ] Handle document type detection
  - [ ] Add manual override options
- [ ] Implement path configuration (AC: 4)
  - [ ] Create VaultPathManager
  - [ ] Add vault detection logic
  - [ ] Build configuration interface
  - [ ] Implement path validation
  - [ ] Add multiple vault support
  - [ ] Create path fallback system
- [ ] Ensure cross-platform compatibility (AC: 5)
  - [ ] Implement PathNormalizer utility
  - [ ] Handle Windows drive letters
  - [ ] Support Unix-style paths
  - [ ] Test path separators
  - [ ] Add symbolic link support
  - [ ] Handle long path names
- [ ] Manage folder permissions (AC: 6)
  - [ ] Check write permissions
  - [ ] Create folders with proper rights
  - [ ] Handle permission errors gracefully
  - [ ] Add permission recovery
  - [ ] Support restricted environments
  - [ ] Log permission issues

## Dev Notes

### Vault Structure Architecture:
```typescript
interface VaultStructure {
  rootPath: string;
  folders: VaultFolder[];
  namingConvention: NamingConvention;
  permissions: PermissionSettings;
}

interface VaultFolder {
  name: string;
  path: string;
  purpose: string;
  allowedTypes: DocumentType[];
  autoCleanup: boolean;
  template?: string;
}

class VaultStructureManager {
  private structure: VaultStructure;
  private pathManager: VaultPathManager;
  
  async initialize(vaultPath: string): Promise<void> {
    // Validate vault path
    await this.validateVaultPath(vaultPath);
    
    // Create standard structure
    await this.createStandardStructure();
    
    // Set up naming conventions
    this.setupNamingConventions();
    
    // Verify permissions
    await this.verifyPermissions();
  }
  
  private async createStandardStructure(): Promise<void> {
    const folders: VaultFolder[] = [
      {
        name: 'ðŸ“¥ Inbox',
        path: 'Inbox',
        purpose: 'Temporary storage for new content and ideas',
        allowedTypes: ['content-brief', 'raw-input', 'draft'],
        autoCleanup: true,
        template: 'inbox-note'
      },
      {
        name: 'ðŸ“š Learning',
        path: 'Learning',
        purpose: 'Knowledge synthesis and learning materials',
        allowedTypes: ['knowledge-synthesis', 'learning-path', 'concept-map'],
        autoCleanup: false,
        template: 'learning-note'
      },
      {
        name: 'âœï¸ Creation',
        path: 'Creation',
        purpose: 'Work-in-progress content drafts',
        allowedTypes: ['content-draft', 'outline', 'iteration'],
        autoCleanup: false,
        template: 'content-draft'
      },
      {
        name: 'ðŸ“¤ Published',
        path: 'Published',
        purpose: 'Finalized content ready for or already published',
        allowedTypes: ['platform-adaptation', 'final-content'],
        autoCleanup: false,
        template: 'published-content'
      },
      {
        name: 'ðŸ§  Knowledge-Base',
        path: 'Knowledge-Base',
        purpose: 'Permanent knowledge and reference materials',
        allowedTypes: ['permanent-note', 'reference', 'methodology'],
        autoCleanup: false,
        template: 'knowledge-note'
      },
      {
        name: 'ðŸ“‹ Templates',
        path: 'Templates',
        purpose: 'Document templates for FLCM agents',
        allowedTypes: ['template'],
        autoCleanup: false
      },
      {
        name: 'ðŸ”§ System',
        path: '.flcm',
        purpose: 'FLCM configuration and metadata',
        allowedTypes: ['config', 'log', 'metadata'],
        autoCleanup: true
      }
    ];
    
    for (const folder of folders) {
      await this.createFolderIfNeeded(folder);
    }
  }
}
```

### File Naming Convention System:
```typescript
interface NamingConvention {
  pattern: string;
  dateFormat: string;
  slugOptions: SlugOptions;
  maxLength: number;
  reservedNames: string[];
}

interface SlugOptions {
  lowercase: boolean;
  separator: string;
  maxWords: number;
  removeStopWords: boolean;
}

class FileNameGenerator {
  private convention: NamingConvention;
  
  constructor() {
    this.convention = {
      pattern: '{type}-{date}-{slug}',
      dateFormat: 'YYYY-MM-DD',
      slugOptions: {
        lowercase: true,
        separator: '-',
        maxWords: 8,
        removeStopWords: true
      },
      maxLength: 100,
      reservedNames: ['con', 'aux', 'prn', 'nul'] // Windows reserved names
    };
  }
  
  generateFileName(document: Document): string {
    const type = this.getTypePrefix(document.type);
    const date = this.formatDate(document.createdAt);
    const slug = this.generateSlug(document.title);
    
    let fileName = this.convention.pattern
      .replace('{type}', type)
      .replace('{date}', date)
      .replace('{slug}', slug);
    
    // Ensure uniqueness
    fileName = this.ensureUniqueness(fileName);
    
    // Validate length and characters
    fileName = this.validateFileName(fileName);
    
    return `${fileName}.md`;
  }
  
  private generateSlug(title: string): string {
    let slug = title.toLowerCase();
    
    // Remove stop words if enabled
    if (this.convention.slugOptions.removeStopWords) {
      slug = this.removeStopWords(slug);
    }
    
    // Replace special characters
    slug = slug
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
      .replace(/[^a-z0-9\s-]/g, '') // Remove special chars
      .replace(/\s+/g, this.convention.slugOptions.separator) // Replace spaces
      .replace(/-+/g, '-') // Remove duplicate separators
      .trim('-'); // Remove leading/trailing separators
    
    // Limit word count
    const words = slug.split(this.convention.slugOptions.separator);
    if (words.length > this.convention.slugOptions.maxWords) {
      slug = words.slice(0, this.convention.slugOptions.maxWords).join(this.convention.slugOptions.separator);
    }
    
    return slug;
  }
  
  private getTypePrefix(docType: DocumentType): string {
    const prefixes = {
      'content-brief': 'cb',
      'knowledge-synthesis': 'ks',
      'content-draft': 'cd',
      'platform-adaptation': 'pa',
      'learning-path': 'lp',
      'concept-map': 'cm',
      'permanent-note': 'pn',
      'reference': 'ref',
      'methodology': 'method'
    };
    
    return prefixes[docType] || 'doc';
  }
}
```

### Automatic File Placement System:
```typescript
interface PlacementRule {
  condition: PlacementCondition;
  targetFolder: string;
  priority: number;
}

interface PlacementCondition {
  documentType?: DocumentType[];
  status?: DocumentStatus[];
  agent?: AgentType[];
  metadata?: Record<string, any>;
}

class DocumentClassifier {
  private rules: PlacementRule[];
  
  constructor() {
    this.rules = [
      // Inbox rules
      {
        condition: { status: ['draft', 'raw'] },
        targetFolder: 'Inbox',
        priority: 1
      },
      
      // Learning rules
      {
        condition: { 
          documentType: ['knowledge-synthesis', 'learning-path'],
          agent: ['Scholar'] 
        },
        targetFolder: 'Learning',
        priority: 2
      },
      
      // Creation rules
      {
        condition: { 
          documentType: ['content-draft'],
          status: ['in-progress', 'review']
        },
        targetFolder: 'Creation',
        priority: 2
      },
      
      // Published rules
      {
        condition: { 
          status: ['published', 'completed'],
          documentType: ['platform-adaptation']
        },
        targetFolder: 'Published',
        priority: 3
      },
      
      // Knowledge Base rules
      {
        condition: { 
          documentType: ['permanent-note', 'methodology'],
          status: ['completed']
        },
        targetFolder: 'Knowledge-Base',
        priority: 4
      }
    ];
  }
  
  classifyDocument(document: Document): string {
    // Find matching rules
    const matchingRules = this.rules.filter(rule => 
      this.matchesCondition(document, rule.condition)
    );
    
    // Sort by priority (higher first)
    matchingRules.sort((a, b) => b.priority - a.priority);
    
    // Return first match or default to Inbox
    return matchingRules[0]?.targetFolder || 'Inbox';
  }
  
  private matchesCondition(document: Document, condition: PlacementCondition): boolean {
    // Check document type
    if (condition.documentType && !condition.documentType.includes(document.type)) {
      return false;
    }
    
    // Check status
    if (condition.status && !condition.status.includes(document.status)) {
      return false;
    }
    
    // Check agent
    if (condition.agent && !condition.agent.includes(document.createdBy)) {
      return false;
    }
    
    // Check metadata
    if (condition.metadata) {
      for (const [key, value] of Object.entries(condition.metadata)) {
        if (document.metadata[key] !== value) {
          return false;
        }
      }
    }
    
    return true;
  }
}
```

### Cross-Platform Path Management:
```typescript
class VaultPathManager {
  private os = require('os');
  private path = require('path');
  
  normalizePath(inputPath: string): string {
    // Handle different path formats
    let normalizedPath = inputPath;
    
    // Convert backslashes to forward slashes
    normalizedPath = normalizedPath.replace(/\\/g, '/');
    
    // Handle Windows drive letters
    if (this.isWindows()) {
      normalizedPath = this.handleWindowsPaths(normalizedPath);
    }
    
    // Resolve relative paths
    normalizedPath = this.path.resolve(normalizedPath);
    
    // Handle symbolic links
    try {
      normalizedPath = this.path.realpath(normalizedPath);
    } catch (error) {
      // Path might not exist yet, keep normalized version
    }
    
    return normalizedPath;
  }
  
  async validateVaultPath(vaultPath: string): Promise<ValidationResult> {
    const normalizedPath = this.normalizePath(vaultPath);
    
    try {
      // Check if path exists
      const stats = await this.fs.stat(normalizedPath);
      
      if (!stats.isDirectory()) {
        return { valid: false, error: 'Path is not a directory' };
      }
      
      // Check for .obsidian folder
      const obsidianPath = this.path.join(normalizedPath, '.obsidian');
      try {
        await this.fs.access(obsidianPath);
        return { valid: true, isObsidianVault: true };
      } catch {
        return { 
          valid: true, 
          isObsidianVault: false,
          warning: 'No .obsidian folder found - may not be an Obsidian vault'
        };
      }
      
    } catch (error) {
      return { 
        valid: false, 
        error: `Cannot access path: ${error.message}` 
      };
    }
  }
  
  private isWindows(): boolean {
    return this.os.platform() === 'win32';
  }
  
  private handleWindowsPaths(path: string): string {
    // Handle UNC paths (\\server\share)
    if (path.startsWith('//')) {
      return path.replace(/^\/\//, '\\\\');
    }
    
    // Handle drive letters
    if (/^\/[a-zA-Z]:/.test(path)) {
      return path.substring(1);
    }
    
    return path;
  }
}
```

### Permission Management:
```typescript
interface PermissionSettings {
  readRequired: boolean;
  writeRequired: boolean;
  createFolders: boolean;
  modifyExisting: boolean;
}

class PermissionManager {
  async checkPermissions(vaultPath: string): Promise<PermissionCheck> {
    const permissions = {
      canRead: false,
      canWrite: false,
      canCreateFolders: false,
      canModifyFiles: false,
      errors: []
    };
    
    try {
      // Test read permission
      await this.fs.access(vaultPath, this.fs.constants.R_OK);
      permissions.canRead = true;
    } catch (error) {
      permissions.errors.push(`Cannot read vault: ${error.message}`);
    }
    
    try {
      // Test write permission
      await this.fs.access(vaultPath, this.fs.constants.W_OK);
      permissions.canWrite = true;
    } catch (error) {
      permissions.errors.push(`Cannot write to vault: ${error.message}`);
    }
    
    // Test folder creation
    if (permissions.canWrite) {
      try {
        const testDir = this.path.join(vaultPath, '.flcm-test');
        await this.fs.mkdir(testDir);
        await this.fs.rmdir(testDir);
        permissions.canCreateFolders = true;
      } catch (error) {
        permissions.errors.push(`Cannot create folders: ${error.message}`);
      }
    }
    
    // Test file modification
    if (permissions.canWrite) {
      try {
        const testFile = this.path.join(vaultPath, '.flcm-test.md');
        await this.fs.writeFile(testFile, '# Test');
        await this.fs.unlink(testFile);
        permissions.canModifyFiles = true;
      } catch (error) {
        permissions.errors.push(`Cannot modify files: ${error.message}`);
      }
    }
    
    return permissions;
  }
  
  async createFolderWithPermissions(folderPath: string): Promise<void> {
    try {
      await this.fs.mkdir(folderPath, { recursive: true, mode: 0o755 });
    } catch (error) {
      if (error.code === 'EEXIST') {
        // Folder already exists, verify it's accessible
        await this.fs.access(folderPath, this.fs.constants.W_OK);
      } else {
        throw new Error(`Cannot create folder ${folderPath}: ${error.message}`);
      }
    }
  }
}
```

### Testing
**Testing Framework:** Jest
**Test File Location:** `.flcm-core/tests/obsidian/`

**Unit Tests:**
- Folder structure creation
- File naming convention validation
- Path normalization across platforms
- Permission checking and handling
- Document classification accuracy
- Slug generation and uniqueness

**Integration Tests:**
- Complete vault setup process
- File placement workflow
- Cross-platform compatibility
- Permission error recovery
- Existing vault integration

**Test Scenarios:**
```
tests/fixtures/obsidian/
â”œâ”€â”€ empty-vault/
â”œâ”€â”€ existing-vault/
â”œâ”€â”€ restricted-permissions/
â”œâ”€â”€ windows-paths/
â”œâ”€â”€ unicode-names/
â””â”€â”€ large-vault/
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_