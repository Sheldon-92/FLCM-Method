# Story 9.1: Agent Communication Protocol

## Status
Approved

## Story
**As a** system,  
**I want** agents to communicate effectively,  
**so that** workflows are smooth and reliable.

**Estimated Time:** 5-6 hours

## Acceptance Criteria
1. Message passing protocol defined
2. State synchronization implemented
3. Error propagation handled
4. Async communication supported
5. Queue management added
6. Transaction support implemented

## Tasks / Subtasks
- [ ] Define message passing protocol (AC: 1)
  - [ ] Create AgentMessage interface
  - [ ] Define message types (request, response, event)
  - [ ] Implement message routing system
  - [ ] Add correlation ID tracking
  - [ ] Create message validation
  - [ ] Define serialization format
- [ ] Implement state synchronization (AC: 2)
  - [ ] Create shared state manager
  - [ ] Implement state update protocol
  - [ ] Add state versioning
  - [ ] Handle concurrent updates
  - [ ] Create state snapshot capability
  - [ ] Implement state recovery
- [ ] Build error propagation system (AC: 3)
  - [ ] Define error message format
  - [ ] Create error routing logic
  - [ ] Implement error recovery strategies
  - [ ] Add error logging
  - [ ] Create fallback mechanisms
  - [ ] Build error notification system
- [ ] Add async communication support (AC: 4)
  - [ ] Implement promise-based messaging
  - [ ] Create callback system
  - [ ] Add timeout handling
  - [ ] Support fire-and-forget messages
  - [ ] Implement async/await patterns
  - [ ] Handle message ordering
- [ ] Implement queue management (AC: 5)
  - [ ] Create message queue system
  - [ ] Add priority queue support
  - [ ] Implement queue overflow handling
  - [ ] Add dead letter queue
  - [ ] Create queue monitoring
  - [ ] Implement backpressure handling
- [ ] Add transaction support (AC: 6)
  - [ ] Define transaction boundaries
  - [ ] Implement rollback capability
  - [ ] Add compensation logic
  - [ ] Create transaction logging
  - [ ] Handle partial failures
  - [ ] Implement saga pattern

## Dev Notes

### Agent Communication Architecture (from docs/architecture/backend-architecture.md):
Base agent framework from Story 1.4 provides foundation. This story extends it with communication protocol.

### Message Protocol:
```typescript
interface AgentMessage {
  id: string;
  correlationId?: string;
  from: AgentId;
  to: AgentId | 'broadcast';
  type: MessageType;
  payload: any;
  metadata: MessageMetadata;
  timestamp: Date;
}

enum MessageType {
  REQUEST = 'request',
  RESPONSE = 'response',
  EVENT = 'event',
  ERROR = 'error',
  STATUS = 'status'
}

interface MessageMetadata {
  priority: 'high' | 'normal' | 'low';
  timeout?: number;
  retryCount?: number;
  transactionId?: string;
  version: string;
}
```

### State Synchronization:
```typescript
class StateManager {
  private state: Map<string, AgentState>;
  private version: number = 0;
  
  async updateState(agentId: string, update: Partial<AgentState>): Promise<void> {
    // Lock state for update
    await this.lock(agentId);
    
    // Apply update
    const current = this.state.get(agentId);
    const updated = { ...current, ...update };
    
    // Version and save
    this.version++;
    this.state.set(agentId, updated);
    
    // Notify subscribers
    await this.notifyStateChange(agentId, updated);
    
    // Release lock
    this.unlock(agentId);
  }
  
  async getState(agentId: string): Promise<AgentState> {
    return this.state.get(agentId);
  }
}
```

### Error Propagation:
```typescript
class ErrorPropagator {
  propagate(error: AgentError, source: AgentId): void {
    // Create error message
    const errorMessage: AgentMessage = {
      type: MessageType.ERROR,
      from: source,
      to: 'broadcast',
      payload: {
        error: error.message,
        code: error.code,
        stack: error.stack,
        recoverable: error.recoverable
      }
    };
    
    // Route to error handlers
    this.routeError(errorMessage);
    
    // Apply recovery strategy
    if (error.recoverable) {
      this.attemptRecovery(error, source);
    }
  }
}
```

### Message Queue:
```typescript
class MessageQueue {
  private queues: Map<AgentId, PriorityQueue<AgentMessage>>;
  private deadLetterQueue: AgentMessage[];
  
  async enqueue(message: AgentMessage): Promise<void> {
    const queue = this.queues.get(message.to);
    
    if (queue.isFull()) {
      // Handle overflow
      if (message.metadata.priority === 'high') {
        // Drop lowest priority message
        queue.dropLowest();
      } else {
        // Send to dead letter queue
        this.deadLetterQueue.push(message);
        return;
      }
    }
    
    queue.add(message, message.metadata.priority);
  }
  
  async dequeue(agentId: AgentId): Promise<AgentMessage | null> {
    const queue = this.queues.get(agentId);
    return queue.poll();
  }
}
```

### Transaction Support:
```typescript
interface Transaction {
  id: string;
  agents: AgentId[];
  operations: Operation[];
  status: 'pending' | 'committed' | 'rolled_back';
  compensations: Compensation[];
}

class TransactionManager {
  async beginTransaction(agents: AgentId[]): Promise<Transaction> {
    const tx: Transaction = {
      id: generateId(),
      agents,
      operations: [],
      status: 'pending',
      compensations: []
    };
    
    // Notify agents of transaction start
    await this.notifyTransactionStart(tx);
    
    return tx;
  }
  
  async commit(tx: Transaction): Promise<void> {
    try {
      // Execute all operations
      for (const op of tx.operations) {
        await this.executeOperation(op);
      }
      
      tx.status = 'committed';
      await this.notifyTransactionCommit(tx);
      
    } catch (error) {
      // Rollback on failure
      await this.rollback(tx);
      throw error;
    }
  }
  
  async rollback(tx: Transaction): Promise<void> {
    // Execute compensations in reverse order
    for (const comp of tx.compensations.reverse()) {
      await this.executeCompensation(comp);
    }
    
    tx.status = 'rolled_back';
    await this.notifyTransactionRollback(tx);
  }
}
```

### Communication Patterns:
1. **Request-Response**: Synchronous communication
2. **Publish-Subscribe**: Event broadcasting
3. **Pipeline**: Sequential processing
4. **Saga**: Long-running transactions

### Testing
**Testing Framework:** Jest
**Test File Location:** `.flcm-core/tests/orchestration/`

**Unit Tests:**
- Message routing logic
- State synchronization
- Error propagation
- Queue operations
- Transaction management

**Integration Tests:**
- Multi-agent communication
- Transaction across agents
- Error recovery scenarios
- Queue overflow handling
- State consistency

**Test Scenarios:**
- Happy path: Collector â†’ Creator
- Error recovery: Failed agent restart
- Transaction: Multi-agent operation
- Overload: Queue management

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_