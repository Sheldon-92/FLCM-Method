# Story 10.4: Template System Integration

## Status
Approved

## Story
**As a** user,  
**I want** consistent document templates,  
**so that** all content follows predictable structure.

**Estimated Time:** 4-5 hours

## Acceptance Criteria
1. Template files in vault Templates/ folder
2. Variable substitution in templates ({{date}}, {{title}}, etc.)
3. Agent-specific template selection
4. Template versioning and updates
5. Custom template creation support
6. Default content for each document type

## Tasks / Subtasks
- [ ] Implement template file system (AC: 1)
  - [ ] Create TemplateManager class
  - [ ] Build template directory structure
  - [ ] Implement template loading
  - [ ] Add template validation
  - [ ] Create template metadata system
  - [ ] Handle template conflicts
- [ ] Build variable substitution system (AC: 2)
  - [ ] Create VariableProcessor service
  - [ ] Define standard variables
  - [ ] Implement substitution engine
  - [ ] Add conditional logic support
  - [ ] Create nested variable handling
  - [ ] Build variable validation
- [ ] Implement agent-specific templates (AC: 3)
  - [ ] Create AgentTemplateSelector
  - [ ] Define agent template mapping
  - [ ] Build template inheritance
  - [ ] Add agent-specific variables
  - [ ] Implement template priority system
  - [ ] Create fallback templates
- [ ] Add template versioning (AC: 4)
  - [ ] Create TemplateVersionManager
  - [ ] Implement version tracking
  - [ ] Build update mechanisms
  - [ ] Add migration support
  - [ ] Create version comparison
  - [ ] Handle version conflicts
- [ ] Support custom templates (AC: 5)
  - [ ] Create CustomTemplateBuilder
  - [ ] Build template editor interface
  - [ ] Add template validation
  - [ ] Implement template sharing
  - [ ] Create template library
  - [ ] Add template preview
- [ ] Implement default content system (AC: 6)
  - [ ] Define document type templates
  - [ ] Create content generators
  - [ ] Build smart defaults
  - [ ] Add context-aware content
  - [ ] Implement template selection logic
  - [ ] Create template documentation

## Dev Notes

### Template System Architecture:
```typescript
interface Template {
  id: string;
  name: string;
  description: string;
  filePath: string;
  content: string;
  variables: TemplateVariable[];
  metadata: TemplateMetadata;
  version: string;
  agentTypes: AgentType[];
  documentTypes: DocumentType[];
}

interface TemplateVariable {
  name: string;
  type: 'string' | 'date' | 'number' | 'boolean' | 'list' | 'object';
  required: boolean;
  defaultValue?: any;
  description: string;
  validation?: ValidationRule[];
}

interface TemplateMetadata {
  author: string;
  created: Date;
  modified: Date;
  tags: string[];
  category: string;
  usage: number;
  isDefault: boolean;
  isCustom: boolean;
}

class TemplateManager {
  private templates: Map<string, Template> = new Map();
  private templatePath: string;
  
  constructor(vaultPath: string) {
    this.templatePath = path.join(vaultPath, 'Templates');
  }
  
  async initialize(): Promise<void> {
    // Create Templates directory if it doesn't exist
    await this.ensureTemplateDirectory();
    
    // Load built-in templates
    await this.loadBuiltInTemplates();
    
    // Load custom templates from vault
    await this.loadCustomTemplates();
    
    // Validate all templates
    await this.validateTemplates();
  }
  
  private async loadBuiltInTemplates(): Promise<void> {
    const builtInTemplates = [
      {
        id: 'content-brief-default',
        name: 'Content Brief Template',
        description: 'Standard template for content briefs created by Collector Agent',
        content: await this.loadTemplateContent('content-brief.md'),
        agentTypes: ['Collector'],
        documentTypes: ['content-brief']
      },
      {
        id: 'knowledge-synthesis-default',
        name: 'Knowledge Synthesis Template',
        description: 'Template for Scholar Agent knowledge synthesis',
        content: await this.loadTemplateContent('knowledge-synthesis.md'),
        agentTypes: ['Scholar'],
        documentTypes: ['knowledge-synthesis']
      },
      {
        id: 'content-draft-default',
        name: 'Content Draft Template',
        description: 'Template for Creator Agent content drafts',
        content: await this.loadTemplateContent('content-draft.md'),
        agentTypes: ['Creator'],
        documentTypes: ['content-draft']
      },
      {
        id: 'platform-adaptation-default',
        name: 'Platform Adaptation Template',
        description: 'Template for Adapter Agent platform adaptations',
        content: await this.loadTemplateContent('platform-adaptation.md'),
        agentTypes: ['Adapter'],
        documentTypes: ['platform-adaptation']
      }
    ];
    
    for (const templateData of builtInTemplates) {
      const template = await this.createTemplate(templateData);
      this.templates.set(template.id, template);
    }
  }
  
  async selectTemplate(
    agentType: AgentType,
    documentType: DocumentType,
    customCriteria?: TemplateSelectionCriteria
  ): Promise<Template> {
    // Find templates matching criteria
    const candidates = Array.from(this.templates.values())
      .filter(template => 
        template.agentTypes.includes(agentType) &&
        template.documentTypes.includes(documentType)
      );
    
    if (candidates.length === 0) {
      throw new Error(`No template found for ${agentType} creating ${documentType}`);
    }
    
    // Apply custom criteria if provided
    let filteredCandidates = candidates;
    if (customCriteria) {
      filteredCandidates = this.applySelectionCriteria(candidates, customCriteria);
    }
    
    // Sort by priority (default templates last, custom first, most used first)
    filteredCandidates.sort((a, b) => {
      if (a.metadata.isCustom !== b.metadata.isCustom) {
        return a.metadata.isCustom ? -1 : 1;
      }
      return b.metadata.usage - a.metadata.usage;
    });
    
    return filteredCandidates[0];
  }
}
```

### Variable Substitution System:
```typescript
interface VariableContext {
  document: Partial<Document>;
  agent: AgentType;
  workflow: WorkflowContext;
  user: UserContext;
  system: SystemContext;
}

interface SystemContext {
  currentDate: Date;
  vaultPath: string;
  templateVersion: string;
  generationId: string;
}

class VariableProcessor {
  private standardVariables: Map<string, VariableProcessor> = new Map();
  
  constructor() {
    this.registerStandardVariables();
  }
  
  async processTemplate(template: Template, context: VariableContext): Promise<string> {
    let processedContent = template.content;
    
    // Process all variables in the template
    const variables = this.extractVariables(template.content);
    
    for (const variable of variables) {
      const value = await this.resolveVariable(variable, context);
      const placeholder = `{{${variable.name}}}`;
      processedContent = processedContent.replace(
        new RegExp(this.escapeRegex(placeholder), 'g'),
        value
      );
    }
    
    // Process conditional blocks
    processedContent = await this.processConditionals(processedContent, context);
    
    // Process loops
    processedContent = await this.processLoops(processedContent, context);
    
    return processedContent;
  }
  
  private registerStandardVariables(): void {
    // Date/time variables
    this.standardVariables.set('date', (context) => 
      context.system.currentDate.toISOString().split('T')[0]
    );
    this.standardVariables.set('datetime', (context) => 
      context.system.currentDate.toISOString()
    );
    this.standardVariables.set('timestamp', (context) => 
      context.system.currentDate.getTime().toString()
    );
    
    // Document variables
    this.standardVariables.set('title', (context) => 
      context.document.title || 'Untitled'
    );
    this.standardVariables.set('id', (context) => 
      context.document.id || this.generateId()
    );
    this.standardVariables.set('type', (context) => 
      context.document.type || 'unknown'
    );
    
    // Agent variables
    this.standardVariables.set('agent', (context) => context.agent);
    this.standardVariables.set('agent_description', (context) => 
      this.getAgentDescription(context.agent)
    );
    
    // User variables
    this.standardVariables.set('user_name', (context) => 
      context.user.name || 'User'
    );
    this.standardVariables.set('user_preferences', (context) => 
      JSON.stringify(context.user.preferences || {})
    );
    
    // System variables
    this.standardVariables.set('vault_path', (context) => 
      context.system.vaultPath
    );
    this.standardVariables.set('generation_id', (context) => 
      context.system.generationId
    );
  }
  
  private async resolveVariable(
    variable: ExtractedVariable, 
    context: VariableContext
  ): Promise<string> {
    // Check standard variables first
    if (this.standardVariables.has(variable.name)) {
      const processor = this.standardVariables.get(variable.name)!;
      return processor(context);
    }
    
    // Check document metadata
    if (context.document.metadata?.[variable.name]) {
      return String(context.document.metadata[variable.name]);
    }
    
    // Check user custom variables
    if (context.user.customVariables?.[variable.name]) {
      return String(context.user.customVariables[variable.name]);
    }
    
    // Check for computed variables
    const computedValue = await this.computeVariable(variable.name, context);
    if (computedValue !== undefined) {
      return computedValue;
    }
    
    // Return placeholder if not found (for debugging)
    return `{{${variable.name}}}`;
  }
  
  private async computeVariable(variableName: string, context: VariableContext): Promise<string | undefined> {
    switch (variableName) {
      case 'word_count':
        return context.document.content ? 
          this.countWords(context.document.content).toString() : '0';
      
      case 'reading_time':
        const wordCount = context.document.content ? 
          this.countWords(context.document.content) : 0;
        const readingTime = Math.ceil(wordCount / 200); // 200 words per minute
        return `${readingTime} min`;
      
      case 'sources_count':
        return context.document.sources?.length?.toString() || '0';
      
      case 'last_modified':
        return context.document.modifiedAt?.toISOString().split('T')[0] || 
               context.system.currentDate.toISOString().split('T')[0];
      
      case 'methodology_list':
        return context.document.methodologies?.join(', ') || 'None';
      
      default:
        return undefined;
    }
  }
  
  private async processConditionals(content: string, context: VariableContext): Promise<string> {
    // Process {{#if condition}} blocks
    const conditionalRegex = /{{#if\s+([^}]+)}}([\s\S]*?){{\/if}}/g;
    let match;
    
    while ((match = conditionalRegex.exec(content)) !== null) {
      const condition = match[1].trim();
      const blockContent = match[2];
      
      const shouldInclude = await this.evaluateCondition(condition, context);
      const replacement = shouldInclude ? blockContent : '';
      
      content = content.replace(match[0], replacement);
    }
    
    return content;
  }
  
  private async evaluateCondition(condition: string, context: VariableContext): Promise<boolean> {
    // Simple condition evaluation
    // Format: variable_name or variable_name == "value" or variable_name != "value"
    
    if (condition.includes('==')) {
      const [variable, expected] = condition.split('==').map(s => s.trim());
      const actualValue = await this.resolveVariable({ name: variable }, context);
      const expectedValue = expected.replace(/['"]/g, '');
      return actualValue === expectedValue;
    }
    
    if (condition.includes('!=')) {
      const [variable, expected] = condition.split('!=').map(s => s.trim());
      const actualValue = await this.resolveVariable({ name: variable }, context);
      const expectedValue = expected.replace(/['"]/g, '');
      return actualValue !== expectedValue;
    }
    
    // Simple existence check
    const value = await this.resolveVariable({ name: condition }, context);
    return value !== undefined && value !== '' && value !== 'undefined';
  }
}
```

### Built-in Templates:

**Content Brief Template:**
```markdown
---
id: {{id}}
title: "{{title}}"
type: content-brief
status: draft
created: {{datetime}}
modified: {{datetime}}
created_by: {{agent}}
generation_id: {{generation_id}}

# Sources
sources: []

# Analysis
confidence:
  overall: 0.0
  factual: 0.0
  logical: 0.0
  creative: 0.0

tags: []
methodologies: []
---

# {{title}}

> **Created by:** {{agent_description}}  
> **Date:** {{date}}  
> **Workflow:** Quick Mode

## üéØ Content Objective

{{#if objective}}
{{objective}}
{{/if}}

*Define the primary goal and target audience for this content.*

## üìä Key Insights

{{#if insights}}
{{#each insights}}
- {{this}}
{{/each}}
{{/if}}

*Main insights and findings from source analysis:*

1. **Primary Insight:** 
2. **Supporting Evidence:** 
3. **Implications:** 

## üèóÔ∏è Content Structure

**Recommended Structure:**
1. **Hook/Opening:** 
2. **Main Points:** 
3. **Supporting Details:** 
4. **Call to Action:** 

## üìã Requirements

- **Word Count:** {{#if word_count_target}}{{word_count_target}}{{else}}500-1000{{/if}} words
- **Tone:** {{#if tone}}{{tone}}{{else}}Professional, engaging{{/if}}
- **Platform:** {{#if target_platform}}{{target_platform}}{{else}}Blog/Article{{/if}}
- **Timeline:** {{#if deadline}}{{deadline}}{{else}}Within 1 week{{/if}}

## üîç Source Analysis

{{#if sources_count}}
**Sources Analyzed:** {{sources_count}}
{{/if}}

*Detailed source breakdown and credibility assessment will be added here.*

## üìù Next Steps

1. [ ] Review and validate insights
2. [ ] Begin knowledge synthesis (Scholar Agent)
3. [ ] Create content draft (Creator Agent)
4. [ ] Optimize for target platform (Adapter Agent)

---

*Generated by FLCM {{agent}} Agent on {{date}}*
```

**Knowledge Synthesis Template:**
```markdown
---
id: {{id}}
title: "{{title}}"
type: knowledge-synthesis
status: draft
created: {{datetime}}
modified: {{datetime}}
created_by: {{agent}}
derived_from: [{{#if content_brief}}"{{content_brief}}"{{/if}}]

# Learning Metrics
understanding_level: surface
confidence:
  overall: 0.0
  conceptual: 0.0
  factual: 0.0

# Methodologies Applied
methodologies: ["Feynman", "Progressive-Depth"]

tags: []
categories: []
---

# {{title}} - Knowledge Synthesis

> **Learning Session**  
> **Agent:** {{agent_description}}  
> **Date:** {{date}}  
> **Understanding Target:** {{#if target_depth}}{{target_depth}}{{else}}Intermediate{{/if}}

## üß† Concept Overview

{{#if brief_summary}}
{{brief_summary}}
{{/if}}

*High-level understanding of the main concept and its significance.*

## üéØ Learning Objectives

By the end of this synthesis, you should be able to:

1. **Explain** the core concept in simple terms
2. **Identify** key components and relationships  
3. **Apply** the knowledge to practical scenarios
4. **Connect** this concept to related ideas

## üìö Progressive Understanding

### Level 1: ELI5 (Explain Like I'm 5)

*Simple, accessible explanation using everyday analogies.*

### Level 2: Intermediate Understanding  

*More detailed explanation with proper terminology.*

### Level 3: Deep Dive

*Comprehensive analysis including nuances, edge cases, and advanced applications.*

{{#if target_depth == "expert"}}
### Level 4: Expert Insights

*Advanced concepts, recent developments, and expert perspectives.*
{{/if}}

## üîó Knowledge Connections

**Builds Upon:**
{{#if prerequisite_concepts}}
{{#each prerequisite_concepts}}
- [[{{this}}]]
{{/each}}
{{/if}}

**Connects To:**
{{#if related_concepts}}
{{#each related_concepts}}
- [[{{this}}]]
{{/each}}
{{/if}}

**Enables Understanding Of:**
{{#if advanced_concepts}}
{{#each advanced_concepts}}
- [[{{this}}]]
{{/each}}
{{/if}}

## üí° Key Insights & Mental Models

1. **Core Pattern:** 
2. **Mental Model:** 
3. **Practical Framework:** 

## üé≠ Analogies & Examples

*Concrete examples and analogies to solidify understanding.*

## ‚ùì Questions for Further Exploration

1. 
2. 
3. 

## üìñ Sources & References

{{#if sources_count}}
*Synthesized from {{sources_count}} sources*
{{/if}}

---

*Knowledge synthesis completed by FLCM Scholar Agent*  
*Reading time: {{reading_time}}*
```

### Template Versioning System:
```typescript
interface TemplateVersion {
  version: string;
  template: Template;
  changelog: ChangelogEntry[];
  migrationInstructions?: MigrationInstruction[];
  deprecated: boolean;
  supportedUntil?: Date;
}

interface MigrationInstruction {
  from: string;
  to: string;
  action: 'rename' | 'transform' | 'remove' | 'add';
  description: string;
  automatic: boolean;
}

class TemplateVersionManager {
  private versions: Map<string, TemplateVersion[]> = new Map();
  
  async updateTemplate(templateId: string, newContent: string, changelog: string): Promise<string> {
    const currentTemplate = await this.getLatestVersion(templateId);
    if (!currentTemplate) {
      throw new Error(`Template ${templateId} not found`);
    }
    
    // Generate new version number
    const newVersion = this.generateNextVersion(currentTemplate.version);
    
    // Create new template version
    const updatedTemplate: Template = {
      ...currentTemplate.template,
      content: newContent,
      version: newVersion,
      metadata: {
        ...currentTemplate.template.metadata,
        modified: new Date()
      }
    };
    
    // Create version entry
    const templateVersion: TemplateVersion = {
      version: newVersion,
      template: updatedTemplate,
      changelog: [
        {
          version: newVersion,
          date: new Date(),
          author: 'system',
          changes: [changelog]
        }
      ],
      deprecated: false
    };
    
    // Store version
    if (!this.versions.has(templateId)) {
      this.versions.set(templateId, []);
    }
    this.versions.get(templateId)!.push(templateVersion);
    
    // Check if migration is needed
    await this.createMigrationInstructions(currentTemplate, templateVersion);
    
    return newVersion;
  }
  
  async migrateDocument(document: Document, fromVersion: string, toVersion: string): Promise<Document> {
    const templateId = this.extractTemplateId(document);
    const migrationPath = await this.findMigrationPath(templateId, fromVersion, toVersion);
    
    let migratedDocument = document;
    
    for (const migration of migrationPath) {
      migratedDocument = await this.applyMigration(migratedDocument, migration);
    }
    
    return migratedDocument;
  }
}
```

### Testing
**Testing Framework:** Jest  
**Test File Location:** `.flcm-core/tests/obsidian/templates/`

**Unit Tests:**
- Template loading and validation
- Variable substitution accuracy
- Conditional logic processing
- Agent-specific template selection
- Version management and migration
- Custom template creation

**Integration Tests:**
- Full template processing workflow
- Cross-agent template compatibility
- Template update and migration
- Custom template sharing
- Template performance with large documents

**Test Templates:**
```
tests/fixtures/templates/
‚îú‚îÄ‚îÄ built-in/
‚îú‚îÄ‚îÄ custom/
‚îú‚îÄ‚îÄ versioned/
‚îú‚îÄ‚îÄ invalid/
‚îú‚îÄ‚îÄ complex-variables/
‚îî‚îÄ‚îÄ migration-scenarios/
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_