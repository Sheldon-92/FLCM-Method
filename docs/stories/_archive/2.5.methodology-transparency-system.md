# Story 2.5: Methodology Transparency System

## Status
Approved

## Story
**As a** user,  
**I want** to see which methodologies are being used,  
**so that** I can learn and trust the system.

**Estimated Time:** 4-5 hours

## Acceptance Criteria
1. Methodology usage logging implemented
2. Real-time methodology status display created
3. Methodology explanation generator built
4. Methodology effectiveness scoring added
5. User methodology preferences supported
6. Methodology recommendation engine created

## Tasks / Subtasks
- [ ] Implement methodology usage logging (AC: 1)
  - [ ] Create MethodologyLogger class
  - [ ] Log methodology invocations
  - [ ] Track input/output pairs
  - [ ] Record execution time
  - [ ] Store success/failure status
  - [ ] Build query interface
- [ ] Create real-time status display (AC: 2)
  - [ ] Build MethodologyMonitor class
  - [ ] Show active methodologies
  - [ ] Display progress indicators
  - [ ] Show completion status
  - [ ] Add time estimates
  - [ ] Create status formatting
- [ ] Build explanation generator (AC: 3)
  - [ ] Create MethodologyExplainer class
  - [ ] Generate what explanations
  - [ ] Provide why reasoning
  - [ ] Show how it works
  - [ ] Include examples
  - [ ] Add learning resources
- [ ] Implement effectiveness scoring (AC: 4)
  - [ ] Define effectiveness metrics
  - [ ] Track output quality
  - [ ] Measure time efficiency
  - [ ] Calculate success rate
  - [ ] Generate effectiveness reports
  - [ ] Compare methodologies
- [ ] Add user preference support (AC: 5)
  - [ ] Create preference interface
  - [ ] Store methodology preferences
  - [ ] Enable methodology toggling
  - [ ] Set complexity preferences
  - [ ] Configure verbosity levels
  - [ ] Save preference profiles
- [ ] Build recommendation engine (AC: 6)
  - [ ] Create MethodologyRecommender
  - [ ] Analyze content type
  - [ ] Consider user goals
  - [ ] Factor in past success
  - [ ] Generate recommendations
  - [ ] Explain recommendations

## Dev Notes

### Methodology Transparency Architecture:
```typescript
interface MethodologyTransparency {
  logger: MethodologyLogger;
  monitor: MethodologyMonitor;
  explainer: MethodologyExplainer;
  scorer: EffectivenessScorer;
  preferences: UserPreferences;
  recommender: MethodologyRecommender;
}

class MethodologyTransparencySystem {
  async executeWithTransparency(
    methodology: Methodology,
    input: any,
    userPrefs: UserPreferences
  ): Promise<TransparentResult> {
    // Log start
    const executionId = await this.logger.logStart(methodology, input);
    
    // Show real-time status
    this.monitor.showExecuting(methodology);
    
    // Execute methodology
    const result = await methodology.execute(input);
    
    // Log completion
    await this.logger.logComplete(executionId, result);
    
    // Generate explanation
    const explanation = await this.explainer.explain(
      methodology,
      input,
      result,
      userPrefs.verbosity
    );
    
    // Score effectiveness
    const score = await this.scorer.score(methodology, result);
    
    return {
      result,
      explanation,
      score,
      methodology: methodology.name,
      executionTime: this.logger.getExecutionTime(executionId)
    };
  }
}
```

### Methodology Usage Logging:
```typescript
interface MethodologyLog {
  id: string;
  methodologyName: string;
  agentId: string;
  input: any;
  output: any;
  startTime: Date;
  endTime: Date;
  success: boolean;
  errorMessage?: string;
  metadata: {
    inputSize: number;
    outputSize: number;
    complexity: number;
  };
}

class MethodologyLogger {
  private logs: Map<string, MethodologyLog> = new Map();
  
  async logStart(methodology: Methodology, input: any): Promise<string> {
    const id = generateId();
    const log: MethodologyLog = {
      id,
      methodologyName: methodology.name,
      agentId: methodology.agent,
      input,
      output: null,
      startTime: new Date(),
      endTime: null,
      success: false,
      metadata: {
        inputSize: JSON.stringify(input).length,
        outputSize: 0,
        complexity: this.calculateComplexity(input)
      }
    };
    
    this.logs.set(id, log);
    await this.persist(log);
    
    return id;
  }
  
  async logComplete(id: string, result: any): Promise<void> {
    const log = this.logs.get(id);
    if (log) {
      log.output = result;
      log.endTime = new Date();
      log.success = true;
      log.metadata.outputSize = JSON.stringify(result).length;
      
      await this.persist(log);
    }
  }
  
  query(filter: LogFilter): MethodologyLog[] {
    return Array.from(this.logs.values())
      .filter(log => this.matchesFilter(log, filter));
  }
}
```

### Real-time Status Display:
```typescript
interface MethodologyStatus {
  name: string;
  status: 'queued' | 'executing' | 'completed' | 'failed';
  progress: number; // 0-100
  estimatedTime: number; // seconds
  message: string;
}

class MethodologyMonitor {
  private activeMethodologies: Map<string, MethodologyStatus> = new Map();
  
  showExecuting(methodology: Methodology): void {
    const status: MethodologyStatus = {
      name: methodology.name,
      status: 'executing',
      progress: 0,
      estimatedTime: this.estimateTime(methodology),
      message: `Applying ${methodology.name}...`
    };
    
    this.activeMethodologies.set(methodology.id, status);
    this.displayStatus(status);
  }
  
  updateProgress(methodologyId: string, progress: number): void {
    const status = this.activeMethodologies.get(methodologyId);
    if (status) {
      status.progress = progress;
      status.message = this.getProgressMessage(status.name, progress);
      this.displayStatus(status);
    }
  }
  
  private displayStatus(status: MethodologyStatus): void {
    // Format for display
    const display = `
🔄 ${status.name}
${this.createProgressBar(status.progress)}
${status.message}
⏱️ Est: ${status.estimatedTime}s
    `;
    
    console.log(display);
  }
  
  private createProgressBar(progress: number): string {
    const filled = Math.floor(progress / 10);
    const empty = 10 - filled;
    return '█'.repeat(filled) + '░'.repeat(empty) + ` ${progress}%`;
  }
}
```

### Methodology Explanation Generator:
```typescript
interface MethodologyExplanation {
  what: string;        // What the methodology does
  why: string;         // Why it's being used
  how: string;         // How it works
  example: string;     // Example of its application
  learning: string[];  // Resources to learn more
}

class MethodologyExplainer {
  explain(
    methodology: Methodology,
    input: any,
    output: any,
    verbosity: 'low' | 'medium' | 'high'
  ): MethodologyExplanation {
    const baseExplanation = this.getBaseExplanation(methodology);
    
    // Adjust based on verbosity
    if (verbosity === 'low') {
      return {
        what: baseExplanation.what,
        why: baseExplanation.why,
        how: '', // Skip technical details
        example: '', // Skip examples
        learning: []
      };
    }
    
    if (verbosity === 'medium') {
      return {
        ...baseExplanation,
        how: this.simplifyHow(baseExplanation.how),
        example: this.getRelevantExample(methodology, input)
      };
    }
    
    // High verbosity - full explanation
    return {
      ...baseExplanation,
      how: this.detailedHow(methodology, input, output),
      example: this.getDetailedExample(methodology, input, output),
      learning: this.getLearningResources(methodology)
    };
  }
  
  private getBaseExplanation(methodology: Methodology): MethodologyExplanation {
    const explanations = {
      'RICE': {
        what: 'RICE scores content by Reach, Impact, Confidence, and Effort',
        why: 'To prioritize the most valuable insights from your sources',
        how: 'Analyzes each piece of information across four dimensions...'
      },
      'Feynman': {
        what: 'The Feynman Technique explains concepts in simple terms',
        why: 'To ensure deep understanding through teaching',
        how: 'Breaks down complex ideas into simple explanations...'
      },
      'SPARK': {
        what: 'SPARK creates engaging content structure',
        why: 'To capture attention and maintain reader interest',
        how: 'Structures content with Situation, Problem, Aspiration...'
      }
    };
    
    return explanations[methodology.name] || this.generateGeneric(methodology);
  }
}
```

### Effectiveness Scoring:
```typescript
interface EffectivenessScore {
  overall: number; // 0-100
  quality: number;
  efficiency: number;
  consistency: number;
  userSatisfaction: number;
}

class EffectivenessScorer {
  score(methodology: Methodology, result: any): EffectivenessScore {
    const quality = this.assessQuality(result);
    const efficiency = this.assessEfficiency(methodology);
    const consistency = this.assessConsistency(methodology);
    const satisfaction = this.getUserSatisfaction(methodology);
    
    return {
      overall: this.calculateOverall(quality, efficiency, consistency, satisfaction),
      quality,
      efficiency,
      consistency,
      userSatisfaction: satisfaction
    };
  }
  
  private assessQuality(result: any): number {
    // Assess output quality
    let score = 50; // Base score
    
    if (result.insights?.length > 5) score += 10;
    if (result.confidence > 0.8) score += 10;
    if (result.completeness > 0.9) score += 10;
    if (result.clarity > 0.85) score += 10;
    if (result.actionable) score += 10;
    
    return Math.min(100, score);
  }
  
  private assessEfficiency(methodology: Methodology): number {
    const avgTime = this.getAverageExecutionTime(methodology);
    const targetTime = this.getTargetTime(methodology);
    
    if (avgTime <= targetTime) return 100;
    if (avgTime <= targetTime * 1.5) return 75;
    if (avgTime <= targetTime * 2) return 50;
    return 25;
  }
}
```

### User Preferences:
```typescript
interface UserMethodologyPreferences {
  userId: string;
  enabled: string[];           // Enabled methodologies
  disabled: string[];          // Disabled methodologies
  favorites: string[];         // Preferred methodologies
  complexity: 'simple' | 'moderate' | 'advanced';
  verbosity: 'low' | 'medium' | 'high';
  autoSelect: boolean;         // Auto-select best methodology
  showExplanations: boolean;
  trackEffectiveness: boolean;
}

class PreferenceManager {
  async setPreferences(userId: string, prefs: Partial<UserMethodologyPreferences>): Promise<void> {
    const current = await this.getPreferences(userId);
    const updated = { ...current, ...prefs };
    
    // Validate preferences
    this.validatePreferences(updated);
    
    // Save
    await this.savePreferences(userId, updated);
    
    // Apply to methodology engine
    this.applyPreferences(updated);
  }
  
  private validatePreferences(prefs: UserMethodologyPreferences): void {
    // Ensure no conflicts
    const enabledSet = new Set(prefs.enabled);
    const disabledSet = new Set(prefs.disabled);
    
    const conflicts = [...enabledSet].filter(m => disabledSet.has(m));
    if (conflicts.length > 0) {
      throw new Error(`Methodology conflict: ${conflicts.join(', ')}`);
    }
  }
}
```

### Recommendation Engine:
```typescript
class MethodologyRecommender {
  recommend(
    content: string,
    goal: string,
    userProfile: UserProfile
  ): MethodologyRecommendation[] {
    const candidates = this.getCandidateMethodologies(goal);
    
    const scored = candidates.map(m => ({
      methodology: m,
      score: this.scoreMethodology(m, content, goal, userProfile)
    }));
    
    const recommendations = scored
      .sort((a, b) => b.score - a.score)
      .slice(0, 3)
      .map(s => ({
        name: s.methodology.name,
        reason: this.explainRecommendation(s.methodology, content, goal),
        confidence: s.score / 100
      }));
    
    return recommendations;
  }
  
  private scoreMethodology(
    methodology: Methodology,
    content: string,
    goal: string,
    userProfile: UserProfile
  ): number {
    let score = 0;
    
    // Goal alignment
    if (this.alignsWithGoal(methodology, goal)) score += 30;
    
    // Content type match
    if (this.matchesContent(methodology, content)) score += 25;
    
    // User preference
    if (userProfile.favorites.includes(methodology.name)) score += 20;
    
    // Past effectiveness
    score += this.getPastEffectiveness(methodology, userProfile) * 15;
    
    // Complexity match
    if (this.matchesComplexity(methodology, userProfile)) score += 10;
    
    return score;
  }
}
```

### Testing
**Testing Framework:** Jest
**Test File Location:** `.flcm-core/tests/methodologies/`

**Unit Tests:**
- Logging accuracy
- Status display formatting
- Explanation generation
- Effectiveness scoring
- Preference management
- Recommendation logic

**Integration Tests:**
- Full transparency flow
- Multi-methodology tracking
- User preference application
- Recommendation accuracy

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_