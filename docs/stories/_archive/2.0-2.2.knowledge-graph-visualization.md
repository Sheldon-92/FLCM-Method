# Story 2.0-2.2: Knowledge Graph Visualization

## Status
Draft

## Story
**As a** visual learner,  
**I want** to see connections between my insights and content,  
**so that** I can discover patterns and relationships in my thinking.

## Acceptance Criteria
1. Graph view shows nodes for insights, content, and frameworks
2. Edge weights represent connection strength
3. Filtering by date, framework, or topic
4. Clickable nodes navigate to documents
5. Automatic clustering of related content
6. Export graph as image or interactive HTML

## Tasks / Subtasks
- [ ] Task 1: Build graph data model (AC: 1)
  - [ ] Subtask 1.1: Design node types for different document types
  - [ ] Subtask 1.2: Create edge relationship definitions
  - [ ] Subtask 1.3: Implement graph data structure
  - [ ] Subtask 1.4: Build graph indexing system

- [ ] Task 2: Implement connection analysis (AC: 2)
  - [ ] Subtask 2.1: Create semantic similarity calculator
  - [ ] Subtask 2.2: Build link strength algorithm
  - [ ] Subtask 2.3: Implement co-occurrence detection
  - [ ] Subtask 2.4: Add temporal proximity weighting

- [ ] Task 3: Create filtering system (AC: 3)
  - [ ] Subtask 3.1: Build date range filter
  - [ ] Subtask 3.2: Implement framework type filter
  - [ ] Subtask 3.3: Create topic/tag filtering
  - [ ] Subtask 3.4: Add custom query language support

- [ ] Task 4: Implement interactive navigation (AC: 4)
  - [ ] Subtask 4.1: Create node click handlers
  - [ ] Subtask 4.2: Build document preview on hover
  - [ ] Subtask 4.3: Implement graph pan and zoom
  - [ ] Subtask 4.4: Add breadcrumb navigation

- [ ] Task 5: Build clustering algorithm (AC: 5)
  - [ ] Subtask 5.1: Implement community detection
  - [ ] Subtask 5.2: Create visual grouping system
  - [ ] Subtask 5.3: Add cluster labeling
  - [ ] Subtask 5.4: Build cluster expansion/collapse

- [ ] Task 6: Create export functionality (AC: 6)
  - [ ] Subtask 6.1: Implement SVG/PNG image export
  - [ ] Subtask 6.2: Build interactive HTML export
  - [ ] Subtask 6.3: Add graph data JSON export
  - [ ] Subtask 6.4: Create Gephi/GraphML export

## Dev Notes

### Graph Data Model
```typescript
// graph-model.ts
interface GraphNode {
    id: string;
    type: 'insight' | 'content' | 'framework' | 'concept';
    title: string;
    path: string;
    metadata: {
        created: Date;
        modified: Date;
        framework?: string;
        layer?: 'mentor' | 'creator' | 'publisher';
        tags: string[];
        wordCount: number;
    };
    position?: { x: number; y: number };
    cluster?: string;
}

interface GraphEdge {
    id: string;
    source: string;
    target: string;
    weight: number;
    type: 'explicit' | 'semantic' | 'temporal' | 'framework';
    metadata: {
        similarity?: number;
        coOccurrence?: number;
        temporalDistance?: number;
    };
}

class KnowledgeGraph {
    nodes: Map<string, GraphNode>;
    edges: Map<string, GraphEdge>;
    clusters: Map<string, Set<string>>;
    
    constructor() {
        this.nodes = new Map();
        this.edges = new Map();
        this.clusters = new Map();
    }
    
    buildFromVault(vault: Vault): void {
        // Extract nodes from documents
        const files = vault.getMarkdownFiles();
        
        for (const file of files) {
            const node = this.createNodeFromFile(file);
            this.nodes.set(node.id, node);
        }
        
        // Calculate edges
        this.calculateSemanticEdges();
        this.extractExplicitLinks();
        this.addTemporalEdges();
        
        // Detect clusters
        this.detectCommunities();
    }
}
```

### Connection Strength Algorithm
```typescript
// connection-analyzer.ts
class ConnectionAnalyzer {
    calculateEdgeWeight(node1: GraphNode, node2: GraphNode): number {
        const weights = {
            explicit: this.getExplicitLinkWeight(node1, node2),
            semantic: this.getSemanticSimilarity(node1, node2),
            temporal: this.getTemporalProximity(node1, node2),
            framework: this.getFrameworkAlignment(node1, node2)
        };
        
        // Weighted combination
        return (
            weights.explicit * 0.4 +
            weights.semantic * 0.3 +
            weights.temporal * 0.1 +
            weights.framework * 0.2
        );
    }
    
    getSemanticSimilarity(node1: GraphNode, node2: GraphNode): number {
        // Load document contents
        const content1 = this.loadContent(node1.path);
        const content2 = this.loadContent(node2.path);
        
        // Convert to embeddings
        const embedding1 = this.getEmbedding(content1);
        const embedding2 = this.getEmbedding(content2);
        
        // Calculate cosine similarity
        return this.cosineSimilarity(embedding1, embedding2);
    }
    
    getTemporalProximity(node1: GraphNode, node2: GraphNode): number {
        const timeDiff = Math.abs(
            node1.metadata.created.getTime() - 
            node2.metadata.created.getTime()
        );
        
        // Decay function: closer in time = stronger connection
        const hoursDiff = timeDiff / (1000 * 60 * 60);
        return Math.exp(-hoursDiff / 168); // Weekly decay
    }
}
```

### Graph Visualization
```typescript
// graph-visualizer.ts
import * as d3 from 'd3';

class GraphVisualizer {
    svg: d3.Selection;
    simulation: d3.Simulation;
    
    constructor(container: HTMLElement) {
        this.svg = d3.select(container)
            .append('svg')
            .attr('width', '100%')
            .attr('height', '100%');
        
        this.setupForceSimulation();
    }
    
    setupForceSimulation() {
        this.simulation = d3.forceSimulation()
            .force('link', d3.forceLink()
                .id(d => d.id)
                .distance(d => 100 / d.weight))
            .force('charge', d3.forceManyBody()
                .strength(-300))
            .force('center', d3.forceCenter())
            .force('collision', d3.forceCollide()
                .radius(d => this.getNodeRadius(d)));
    }
    
    renderGraph(graph: KnowledgeGraph) {
        // Render edges
        const links = this.svg.selectAll('.link')
            .data(Array.from(graph.edges.values()))
            .enter().append('line')
            .attr('class', 'link')
            .style('stroke-width', d => Math.sqrt(d.weight * 10))
            .style('stroke-opacity', d => d.weight);
        
        // Render nodes
        const nodes = this.svg.selectAll('.node')
            .data(Array.from(graph.nodes.values()))
            .enter().append('g')
            .attr('class', d => `node node-${d.type}`)
            .call(this.dragBehavior());
        
        // Add node circles
        nodes.append('circle')
            .attr('r', d => this.getNodeRadius(d))
            .style('fill', d => this.getNodeColor(d));
        
        // Add labels
        nodes.append('text')
            .text(d => d.title)
            .attr('dx', 12)
            .attr('dy', 4);
        
        // Start simulation
        this.simulation
            .nodes(Array.from(graph.nodes.values()))
            .on('tick', () => this.tick());
        
        this.simulation.force('link')
            .links(Array.from(graph.edges.values()));
    }
    
    getNodeColor(node: GraphNode): string {
        const colors = {
            'insight': '#8b5cf6',  // Purple
            'content': '#10b981',  // Green
            'framework': '#f59e0b', // Amber
            'concept': '#3b82f6'   // Blue
        };
        return colors[node.type] || '#6b7280';
    }
}
```

### Filtering System
```typescript
// graph-filter.ts
class GraphFilter {
    activeFilters: FilterCriteria[] = [];
    
    addFilter(filter: FilterCriteria) {
        this.activeFilters.push(filter);
        this.applyFilters();
    }
    
    applyFilters(): FilteredGraph {
        let filteredNodes = new Set(this.graph.nodes.keys());
        let filteredEdges = new Set(this.graph.edges.keys());
        
        for (const filter of this.activeFilters) {
            switch (filter.type) {
                case 'date':
                    filteredNodes = this.filterByDate(filteredNodes, filter);
                    break;
                case 'framework':
                    filteredNodes = this.filterByFramework(filteredNodes, filter);
                    break;
                case 'topic':
                    filteredNodes = this.filterByTopic(filteredNodes, filter);
                    break;
                case 'connection_strength':
                    filteredEdges = this.filterByStrength(filteredEdges, filter);
                    break;
            }
        }
        
        // Remove orphaned edges
        filteredEdges = this.removeOrphanedEdges(filteredEdges, filteredNodes);
        
        return { nodes: filteredNodes, edges: filteredEdges };
    }
    
    filterByDate(nodes: Set<string>, filter: DateFilter): Set<string> {
        const filtered = new Set<string>();
        
        for (const nodeId of nodes) {
            const node = this.graph.nodes.get(nodeId);
            if (node.metadata.created >= filter.start && 
                node.metadata.created <= filter.end) {
                filtered.add(nodeId);
            }
        }
        
        return filtered;
    }
}
```

### Clustering Implementation
```typescript
// graph-clustering.ts
class GraphClusterer {
    detectCommunities(graph: KnowledgeGraph): Map<string, Set<string>> {
        // Use Louvain community detection algorithm
        const communities = this.louvain(graph);
        
        // Post-process communities
        const refined = this.refineCommunities(communities);
        
        // Label communities
        const labeled = this.labelCommunities(refined);
        
        return labeled;
    }
    
    louvain(graph: KnowledgeGraph): Map<string, string> {
        let modularity = 0;
        let previousModularity = -1;
        let communities = new Map<string, string>();
        
        // Initialize: each node in its own community
        for (const nodeId of graph.nodes.keys()) {
            communities.set(nodeId, nodeId);
        }
        
        // Iterate until convergence
        while (modularity - previousModularity > 0.0001) {
            previousModularity = modularity;
            
            // Phase 1: Local optimization
            for (const nodeId of graph.nodes.keys()) {
                const bestCommunity = this.findBestCommunity(nodeId, communities);
                communities.set(nodeId, bestCommunity);
            }
            
            // Phase 2: Community aggregation
            communities = this.aggregateCommunities(communities);
            
            // Calculate new modularity
            modularity = this.calculateModularity(graph, communities);
        }
        
        return communities;
    }
    
    labelCommunities(communities: Map<string, Set<string>>): Map<string, ClusterInfo> {
        const labeled = new Map<string, ClusterInfo>();
        
        for (const [clusterId, nodeIds] of communities) {
            const nodes = Array.from(nodeIds).map(id => this.graph.nodes.get(id));
            
            // Extract common themes
            const commonTags = this.findCommonTags(nodes);
            const dominantFramework = this.findDominantFramework(nodes);
            const label = this.generateClusterLabel(commonTags, dominantFramework);
            
            labeled.set(clusterId, {
                id: clusterId,
                label,
                nodes: nodeIds,
                size: nodeIds.size,
                density: this.calculateClusterDensity(nodeIds)
            });
        }
        
        return labeled;
    }
}
```

### Export Functionality
```typescript
// graph-exporter.ts
class GraphExporter {
    exportAsImage(graph: KnowledgeGraph, format: 'svg' | 'png'): Blob {
        const svg = this.renderToSVG(graph);
        
        if (format === 'svg') {
            return new Blob([svg], { type: 'image/svg+xml' });
        }
        
        // Convert SVG to PNG
        return this.svgToPng(svg);
    }
    
    exportAsInteractiveHTML(graph: KnowledgeGraph): string {
        const template = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>FLCM Knowledge Graph</title>
            <script src="https://d3js.org/d3.v7.min.js"></script>
            <style>
                ${this.getGraphStyles()}
            </style>
        </head>
        <body>
            <div id="graph-container"></div>
            <script>
                const graphData = ${JSON.stringify(this.serializeGraph(graph))};
                ${this.getVisualizationScript()}
            </script>
        </body>
        </html>
        `;
        
        return template;
    }
    
    exportAsGraphML(graph: KnowledgeGraph): string {
        // Export in GraphML format for Gephi
        const xml = this.buildGraphML(graph);
        return xml;
    }
}
```

### Performance Requirements
- Graph rendering: <3s for 1000 nodes
- Filter application: <500ms
- Clustering: <5s for 1000 nodes
- Export generation: <2s

### Testing
- **Test Location**: `tests/knowledge-graph/`
- **Visualization Tests**: `tests/knowledge-graph/rendering/`
- **Algorithm Tests**: `tests/knowledge-graph/algorithms/`
- **Performance Tests**: Test with graphs of 10k+ nodes
- **Export Tests**: Verify all export formats

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-31 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
*To be populated during implementation*

### Agent Model Used
*TBD*

### Debug Log References
*TBD*

### Completion Notes List
*TBD*

### File List
*TBD*

## QA Results
*To be populated during QA*