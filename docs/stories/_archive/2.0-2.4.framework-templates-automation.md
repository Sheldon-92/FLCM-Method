# Story 2.0-2.4: Framework Templates and Automation

## Status
Draft

## Story
**As a** structured thinker,  
**I want** Obsidian templates for each framework,  
**so that** I can apply methodologies directly in my vault.

## Acceptance Criteria
1. Template generated for each framework (SWOT, SCAMPER, etc.)
2. Templates include guided questions and structure
3. Auto-linking to related framework applications
4. Frontmatter tags for framework tracking
5. Quick switcher integration for framework selection
6. Bulk template application to existing notes

## Tasks / Subtasks
- [ ] Task 1: Create framework template system (AC: 1)
  - [ ] Subtask 1.1: Design template structure for each framework
  - [ ] Subtask 1.2: Implement template generation engine
  - [ ] Subtask 1.3: Create template registry
  - [ ] Subtask 1.4: Build template versioning system

- [ ] Task 2: Add guided questions (AC: 2)
  - [ ] Subtask 2.1: Define questions for each framework
  - [ ] Subtask 2.2: Create progressive disclosure system
  - [ ] Subtask 2.3: Implement contextual hints
  - [ ] Subtask 2.4: Add example answers

- [ ] Task 3: Implement auto-linking (AC: 3)
  - [ ] Subtask 3.1: Create link detection algorithm
  - [ ] Subtask 3.2: Build framework relationship map
  - [ ] Subtask 3.3: Implement automatic backlinking
  - [ ] Subtask 3.4: Add link suggestions

- [ ] Task 4: Design frontmatter schema (AC: 4)
  - [ ] Subtask 4.1: Define framework metadata structure
  - [ ] Subtask 4.2: Create tag taxonomy
  - [ ] Subtask 4.3: Implement validation rules
  - [ ] Subtask 4.4: Add metadata inheritance

- [ ] Task 5: Integrate with quick switcher (AC: 5)
  - [ ] Subtask 5.1: Extend Obsidian command palette
  - [ ] Subtask 5.2: Add framework search
  - [ ] Subtask 5.3: Implement hotkeys
  - [ ] Subtask 5.4: Create framework picker UI

- [ ] Task 6: Build bulk application (AC: 6)
  - [ ] Subtask 6.1: Create note selector
  - [ ] Subtask 6.2: Implement batch processor
  - [ ] Subtask 6.3: Add conflict resolution
  - [ ] Subtask 6.4: Build progress tracking

## Dev Notes

### Framework Template Structure
```yaml
# Template: SWOT-USED Analysis
---
flcm:
  framework: swot-used
  version: 2.0
  created: {{date}}
  stage: {{stage}}
  related_frameworks:
    - "[[5W2H Analysis]]"
    - "[[RICE Prioritization]]"
tags:
  - flcm/framework/swot-used
  - flcm/analysis
  - status/in-progress
---

# SWOT-USED Analysis: {{title}}

## Context
> Briefly describe what you're analyzing and why

## SWOT Analysis

### Strengths (Internal Positive)
- 
- 
- 

### Weaknesses (Internal Negative)
- 
- 
- 

### Opportunities (External Positive)
- 
- 
- 

### Threats (External Negative)
- 
- 
- 

## USED Strategy Development

### Use Strengths
> How can we leverage our strengths to maximize opportunities?
- 

### Stop Weaknesses
> How can we stop or minimize our weaknesses?
- 

### Exploit Opportunities
> How can we exploit opportunities using our strengths?
- 

### Defend Against Threats
> How can we defend against threats while addressing weaknesses?
- 

## Action Items
- [ ] 
- [ ] 
- [ ] 

## Related Insights
- [[]]
- [[]]
```

### Template Generation Engine
```typescript
// template-generator.ts
class FrameworkTemplateGenerator {
    private templates: Map<string, FrameworkTemplate>;
    private templater: Templater;
    
    constructor() {
        this.templates = new Map();
        this.loadFrameworkTemplates();
    }
    
    generateTemplate(framework: string, context: TemplateContext): string {
        const template = this.templates.get(framework);
        if (!template) {
            throw new Error(`Unknown framework: ${framework}`);
        }
        
        // Process template with context
        let processed = this.templater.process(template.content, {
            ...context,
            date: new Date().toISOString(),
            stage: this.determineStage(context),
            relatedFrameworks: this.suggestRelated(framework, context)
        });
        
        // Add guided questions if needed
        if (context.includeGuidance) {
            processed = this.addGuidedQuestions(processed, template.questions);
        }
        
        return processed;
    }
    
    private addGuidedQuestions(content: string, questions: Question[]): string {
        // Insert contextual questions as comments
        return content.replace(/^(#+\s+.*)$/gm, (match, heading) => {
            const relevantQuestions = questions.filter(q => 
                q.section === this.extractSection(heading)
            );
            
            if (relevantQuestions.length > 0) {
                const questionText = relevantQuestions
                    .map(q => `> ðŸ’¡ ${q.text}`)
                    .join('\n');
                return `${match}\n${questionText}`;
            }
            
            return match;
        });
    }
}
```

### Framework Question Bank
```typescript
// framework-questions.ts
const frameworkQuestions = {
    'swot-used': {
        strengths: [
            "What unique capabilities do you have?",
            "What resources can you leverage?",
            "What do others see as your strengths?"
        ],
        weaknesses: [
            "What could you improve?",
            "Where do you have fewer resources than others?",
            "What are others likely to see as weaknesses?"
        ],
        opportunities: [
            "What trends could you take advantage of?",
            "How can you turn strengths into opportunities?",
            "What changes in technology could help?"
        ],
        threats: [
            "What obstacles do you face?",
            "What is your competition doing?",
            "Could any weaknesses seriously threaten you?"
        ]
    },
    
    'scamper': {
        substitute: [
            "What can be substituted?",
            "Who else could be involved?",
            "What other materials could work?"
        ],
        combine: [
            "What can be combined?",
            "Can we merge purposes?",
            "What ideas can be blended?"
        ],
        adapt: [
            "What else is like this?",
            "What could be copied?",
            "What idea could be incorporated?"
        ],
        modify: [
            "What can be emphasized?",
            "What can be exaggerated?",
            "What can be understated?"
        ],
        putToOtherUses: [
            "What else can this be used for?",
            "Who else could use this?",
            "How would a child use this?"
        ],
        eliminate: [
            "What can be removed?",
            "What is unnecessary?",
            "What can be simplified?"
        ],
        reverse: [
            "What can be reversed?",
            "What can be turned around?",
            "What is the opposite?"
        ]
    }
};
```

### Auto-linking System
```typescript
// auto-linker.ts
class FrameworkAutoLinker {
    private graph: FrameworkGraph;
    private vault: Vault;
    
    async processTemplate(content: string, framework: string): Promise<string> {
        // Find related framework applications
        const relatedNotes = await this.findRelatedFrameworks(framework);
        
        // Auto-link to related content
        let linked = content;
        
        // Add related frameworks section
        if (relatedNotes.length > 0) {
            linked = this.addRelatedSection(linked, relatedNotes);
        }
        
        // Create backlinks in related notes
        for (const note of relatedNotes) {
            await this.createBacklink(note, content);
        }
        
        // Suggest conceptual links
        const concepts = this.extractConcepts(content);
        linked = this.suggestConceptLinks(linked, concepts);
        
        return linked;
    }
    
    private findRelatedFrameworks(framework: string): Promise<Note[]> {
        // Search vault for notes using same or related frameworks
        const query = `tag:#flcm/framework/${framework} OR tag:#flcm/related/${framework}`;
        return this.vault.search(query);
    }
    
    private extractConcepts(content: string): Concept[] {
        // Use NLP to extract key concepts
        const concepts = [];\n        
        // Extract named entities
        const entities = this.nlp.extractEntities(content);
        concepts.push(...entities);
        
        // Extract key phrases
        const phrases = this.nlp.extractKeyPhrases(content);
        concepts.push(...phrases);
        
        return concepts;
    }
}
```

### Quick Switcher Integration
```typescript
// quick-switcher.ts
class FrameworkQuickSwitcher {
    private modal: Modal;
    private frameworks: Framework[];
    
    constructor(app: App) {
        this.app = app;
        this.registerCommands();
    }
    
    registerCommands() {
        // Register framework command
        this.app.commands.addCommand({
            id: 'flcm-framework-picker',
            name: 'FLCM: Apply Framework Template',
            hotkeys: [{ modifiers: ['Mod', 'Shift'], key: 'F' }],
            callback: () => this.showFrameworkPicker()
        });
        
        // Register individual framework commands
        for (const framework of this.frameworks) {
            this.app.commands.addCommand({
                id: `flcm-framework-${framework.id}`,
                name: `FLCM: Apply ${framework.name}`,
                callback: () => this.applyFramework(framework)
            });
        }
    }
    
    showFrameworkPicker() {
        const modal = new FrameworkPickerModal(this.app);
        modal.onChoose = (framework) => {
            this.applyFramework(framework);
        };
        modal.open();
    }
    
    async applyFramework(framework: Framework) {
        const activeFile = this.app.workspace.getActiveFile();
        
        if (!activeFile) {
            // Create new note with template
            const template = await this.generateTemplate(framework);
            const fileName = `${framework.name} - ${new Date().toLocaleDateString()}.md`;
            await this.app.vault.create(fileName, template);
        } else {
            // Apply template to existing note
            await this.applyToExisting(activeFile, framework);
        }
    }
}
```

### Bulk Template Application
```typescript
// bulk-processor.ts
class BulkTemplateProcessor {
    async applyToMultiple(notes: TFile[], framework: Framework): Promise<BulkResult> {
        const results: ProcessResult[] = [];
        const progressModal = new ProgressModal(this.app);
        progressModal.open();
        
        for (let i = 0; i < notes.length; i++) {
            progressModal.setProgress(i / notes.length);
            progressModal.setMessage(`Processing ${notes[i].name}...`);
            
            try {
                const result = await this.processNote(notes[i], framework);
                results.push(result);
            } catch (error) {
                results.push({
                    note: notes[i],
                    status: 'failed',
                    error: error.message
                });
            }
        }
        
        progressModal.close();
        
        return {
            total: notes.length,
            succeeded: results.filter(r => r.status === 'success').length,
            failed: results.filter(r => r.status === 'failed').length,
            results
        };
    }
    
    private async processNote(note: TFile, framework: Framework): Promise<ProcessResult> {
        const content = await this.app.vault.read(note);
        
        // Check if template already applied
        if (this.hasFramework(content, framework)) {
            return {
                note,
                status: 'skipped',
                reason: 'Template already applied'
            };
        }
        
        // Merge template with existing content
        const merged = await this.mergeTemplate(content, framework);
        
        // Save updated content
        await this.app.vault.modify(note, merged);
        
        return {
            note,
            status: 'success',
            changes: this.summarizeChanges(content, merged)
        };
    }
    
    private mergeTemplate(existing: string, framework: Framework): string {
        const template = this.generateTemplate(framework);
        
        // Parse existing frontmatter
        const existingMeta = this.parseFrontmatter(existing);
        const templateMeta = this.parseFrontmatter(template);
        
        // Merge frontmatter
        const mergedMeta = this.mergeFrontmatter(existingMeta, templateMeta);
        
        // Merge content sections
        const mergedContent = this.mergeContent(existing, template, framework);
        
        return this.assemblDocument(mergedMeta, mergedContent);
    }
}
```

### Template Versioning
```typescript
// template-versioning.ts
class TemplateVersionManager {
    private versions: Map<string, TemplateVersion[]>;
    
    async getTemplate(framework: string, version?: string): Promise<Template> {
        const versions = this.versions.get(framework);
        
        if (!versions || versions.length === 0) {
            throw new Error(`No template found for ${framework}`);
        }
        
        if (version) {
            const specific = versions.find(v => v.version === version);
            if (!specific) {
                throw new Error(`Version ${version} not found for ${framework}`);
            }
            return specific.template;
        }
        
        // Return latest version
        return versions[versions.length - 1].template;
    }
    
    async migrateTemplate(note: TFile, fromVersion: string, toVersion: string) {
        const content = await this.app.vault.read(note);
        const framework = this.detectFramework(content);
        
        const migrations = this.getMigrationPath(framework, fromVersion, toVersion);
        
        let migrated = content;
        for (const migration of migrations) {
            migrated = await migration.apply(migrated);
        }
        
        await this.app.vault.modify(note, migrated);
    }
}
```

### Performance Requirements
- Template generation: <100ms
- Auto-linking: <500ms per note
- Bulk processing: 10 notes/second
- Quick switcher: <50ms response

### Testing
- **Test Location**: `tests/framework-templates/`
- **Template Tests**: `tests/framework-templates/generation/`
- **Linking Tests**: `tests/framework-templates/auto-linking/`
- **Bulk Tests**: Test with 100+ notes
- **Integration Tests**: Verify Obsidian compatibility

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-31 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
*To be populated during implementation*

### Agent Model Used
*TBD*

### Debug Log References
*TBD*

### Completion Notes List
*TBD*

### File List
*TBD*

## QA Results
*To be populated during QA*