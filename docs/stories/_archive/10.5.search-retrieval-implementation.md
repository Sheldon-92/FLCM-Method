# Story 10.5: Search & Retrieval Implementation

## Status
Approved

## Story
**As a** user,  
**I want** to quickly find relevant past content,  
**so that** I can build on previous knowledge.

**Estimated Time:** 4-5 hours

## Acceptance Criteria
1. Users can find relevant content in their vault within 3 seconds using natural search queries
2. Search results are ranked by relevance with 90%+ user satisfaction on result quality
3. Users can filter content by agent, date, tags, and quality with zero training required
4. Tag-based discovery helps users find related content they forgot they had
5. Search works seamlessly with Obsidian's existing search without conflicts
6. Users can search across all metadata and content with consistent, predictable results

## Tasks / Subtasks
- [ ] Implement Obsidian search integration (AC: 1)
  - [ ] Create ObsidianSearchProvider class
  - [ ] Build search syntax parser
  - [ ] Implement query translation
  - [ ] Add search result formatting
  - [ ] Create search operators support
  - [ ] Build search history tracking
- [ ] Build metadata filtering system (AC: 2)
  - [ ] Create MetadataFilter service
  - [ ] Implement agent-based filtering
  - [ ] Add status filtering logic
  - [ ] Build confidence range filtering
  - [ ] Create methodology filtering
  - [ ] Add custom metadata filters
- [ ] Implement tag-based discovery (AC: 3)
  - [ ] Create TagSearchEngine
  - [ ] Build tag hierarchy support
  - [ ] Implement tag suggestions
  - [ ] Add tag clustering
  - [ ] Create tag-based recommendations
  - [ ] Build tag relationship mapping
- [ ] Add date range filtering (AC: 4)
  - [ ] Create DateRangeFilter
  - [ ] Support multiple date types
  - [ ] Build date parsing logic
  - [ ] Add relative date support
  - [ ] Implement date range validation
  - [ ] Create date-based grouping
- [ ] Build full-text search (AC: 5)
  - [ ] Create FullTextSearchEngine
  - [ ] Implement content indexing
  - [ ] Build search tokenization
  - [ ] Add stemming and synonyms
  - [ ] Create phrase search support
  - [ ] Build search highlighting
- [ ] Implement relevance ranking (AC: 6)
  - [ ] Create RelevanceRanker service
  - [ ] Build scoring algorithms
  - [ ] Add user preference weighting
  - [ ] Implement recency bias
  - [ ] Create quality score integration
  - [ ] Build personalized ranking

## Dev Notes

### Search Architecture:
```typescript
interface SearchQuery {
  text?: string;
  filters: SearchFilter[];
  options: SearchOptions;
  userId?: string;
}

interface SearchFilter {
  type: FilterType;
  field: string;
  value: any;
  operator: 'equals' | 'contains' | 'range' | 'in' | 'exists';
}

enum FilterType {
  METADATA = 'metadata',
  TAG = 'tag',
  DATE = 'date',
  AGENT = 'agent',
  STATUS = 'status',
  CONFIDENCE = 'confidence',
  TYPE = 'type'
}

interface SearchOptions {
  limit: number;
  offset: number;
  sortBy: SortOption[];
  includeContent: boolean;
  includePreview: boolean;
  highlightTerms: boolean;
}

interface SearchResult {
  document: Document;
  score: number;
  highlights: SearchHighlight[];
  explanation: string;
  preview?: string;
}

class SearchEngine {
  private providers: Map<string, SearchProvider> = new Map();
  private indexManager: SearchIndexManager;
  private rankingEngine: RelevanceRanker;
  
  constructor(vaultPath: string) {
    this.indexManager = new SearchIndexManager(vaultPath);
    this.rankingEngine = new RelevanceRanker();
    
    // Register search providers
    this.providers.set('obsidian', new ObsidianSearchProvider());
    this.providers.set('fulltext', new FullTextSearchProvider());
    this.providers.set('metadata', new MetadataSearchProvider());
    this.providers.set('semantic', new SemanticSearchProvider());
  }
  
  async search(query: SearchQuery): Promise<SearchResult[]> {
    // Parse and validate query
    const parsedQuery = await this.parseQuery(query);
    
    // Execute search across providers
    const providerResults = await this.executeMultiProviderSearch(parsedQuery);
    
    // Merge and deduplicate results
    const mergedResults = this.mergeSearchResults(providerResults);
    
    // Apply filters
    const filteredResults = this.applyFilters(mergedResults, parsedQuery.filters);
    
    // Rank results by relevance
    const rankedResults = await this.rankingEngine.rankResults(
      filteredResults, 
      parsedQuery
    );
    
    // Apply pagination
    const paginatedResults = this.paginateResults(rankedResults, parsedQuery.options);
    
    // Enhance with previews and highlights
    const enhancedResults = await this.enhanceResults(paginatedResults, parsedQuery);
    
    return enhancedResults;
  }
}
```

### Obsidian Search Integration:
```typescript
class ObsidianSearchProvider implements SearchProvider {
  private obsidianApi: ObsidianAPI;
  
  async search(query: ParsedSearchQuery): Promise<ProviderSearchResult[]> {
    // Convert FLCM query to Obsidian search syntax
    const obsidianQuery = this.convertToObsidianSyntax(query);
    
    // Execute search via Obsidian API
    const obsidianResults = await this.obsidianApi.search(obsidianQuery);
    
    // Convert results to FLCM format
    return obsidianResults.map(result => this.convertFromObsidianResult(result));
  }
  
  private convertToObsidianSyntax(query: ParsedSearchQuery): string {
    const queryParts: string[] = [];
    
    // Add text search
    if (query.text) {
      queryParts.push(`"${query.text}"`);
    }
    
    // Add metadata filters
    query.filters.forEach(filter => {
      switch (filter.type) {
        case FilterType.TAG:
          queryParts.push(`tag:#${filter.value}`);
          break;
        case FilterType.AGENT:
          queryParts.push(`created_by:"${filter.value}"`);
          break;
        case FilterType.TYPE:
          queryParts.push(`type:"${filter.value}"`);
          break;
        case FilterType.DATE:
          if (filter.operator === 'range') {
            const [start, end] = filter.value;
            queryParts.push(`created:[${start} TO ${end}]`);
          }
          break;
      }
    });
    
    // Add file type restrictions
    queryParts.push('path:*.md');
    
    return queryParts.join(' AND ');
  }
  
  private convertFromObsidianResult(obsidianResult: ObsidianSearchResult): ProviderSearchResult {
    return {
      documentId: obsidianResult.file.basename,
      title: obsidianResult.file.basename,
      path: obsidianResult.file.path,
      score: obsidianResult.score || 1.0,
      matches: obsidianResult.matches?.map(match => ({
        content: match.content,
        offset: match.offset,
        length: match.length
      })) || [],
      provider: 'obsidian'
    };
  }
}
```

### Metadata-Based Filtering:
```typescript
class MetadataFilter {
  applyFilters(documents: Document[], filters: SearchFilter[]): Document[] {
    return documents.filter(doc => {
      return filters.every(filter => this.matchesFilter(doc, filter));
    });
  }
  
  private matchesFilter(document: Document, filter: SearchFilter): boolean {
    const value = this.extractFilterValue(document, filter.field);
    
    switch (filter.operator) {
      case 'equals':
        return value === filter.value;
        
      case 'contains':
        if (typeof value === 'string') {
          return value.toLowerCase().includes(filter.value.toLowerCase());
        }
        if (Array.isArray(value)) {
          return value.includes(filter.value);
        }
        return false;
        
      case 'range':
        if (typeof value === 'number' && Array.isArray(filter.value)) {
          const [min, max] = filter.value;
          return value >= min && value <= max;
        }
        if (value instanceof Date && Array.isArray(filter.value)) {
          const [start, end] = filter.value.map(d => new Date(d));
          return value >= start && value <= end;
        }
        return false;
        
      case 'in':
        return Array.isArray(filter.value) && filter.value.includes(value);
        
      case 'exists':
        return value !== undefined && value !== null;
        
      default:
        return false;
    }
  }
  
  private extractFilterValue(document: Document, field: string): any {
    // Handle nested field access (e.g., "confidence.overall")
    const fieldPath = field.split('.');
    let value: any = document;
    
    for (const segment of fieldPath) {
      if (value && typeof value === 'object') {
        value = value[segment];
      } else {
        return undefined;
      }
    }
    
    return value;
  }
  
  async buildFilterSuggestions(field: string): Promise<FilterSuggestion[]> {
    // Analyze all documents to suggest filter values
    const allDocs = await this.documentManager.getAllDocuments();
    const values = new Set<any>();
    
    allDocs.forEach(doc => {
      const value = this.extractFilterValue(doc, field);
      if (value !== undefined && value !== null) {
        if (Array.isArray(value)) {
          value.forEach(v => values.add(v));
        } else {
          values.add(value);
        }
      }
    });
    
    return Array.from(values)
      .sort()
      .map(value => ({
        value,
        count: this.countDocumentsWithValue(allDocs, field, value),
        displayText: String(value)
      }));
  }
}
```

### Tag-Based Discovery:
```typescript
interface TagHierarchy {
  tag: string;
  parent?: string;
  children: string[];
  documentCount: number;
  relatedTags: TagRelation[];
}

interface TagRelation {
  tag: string;
  strength: number; // 0-1 correlation strength
  type: 'synonym' | 'parent' | 'child' | 'related';
}

class TagSearchEngine {
  private tagHierarchy: Map<string, TagHierarchy> = new Map();
  private tagCooccurrence: Map<string, Map<string, number>> = new Map();
  
  async buildTagIndex(documents: Document[]): Promise<void> {
    // Build tag hierarchy and relationships
    const tagCounts = new Map<string, number>();
    const tagCooccurrences = new Map<string, Map<string, number>>();
    
    documents.forEach(doc => {
      const tags = doc.tags || [];
      
      // Count individual tags
      tags.forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
      
      // Build co-occurrence matrix
      for (let i = 0; i < tags.length; i++) {
        for (let j = i + 1; j < tags.length; j++) {
          const tag1 = tags[i];
          const tag2 = tags[j];
          
          if (!tagCooccurrences.has(tag1)) {
            tagCooccurrences.set(tag1, new Map());
          }
          if (!tagCooccurrences.has(tag2)) {
            tagCooccurrences.set(tag2, new Map());
          }
          
          const tag1Relations = tagCooccurrences.get(tag1)!;
          const tag2Relations = tagCooccurrences.get(tag2)!;
          
          tag1Relations.set(tag2, (tag1Relations.get(tag2) || 0) + 1);
          tag2Relations.set(tag1, (tag2Relations.get(tag1) || 0) + 1);
        }
      }
    });
    
    // Build hierarchy
    this.buildTagHierarchy(tagCounts, tagCooccurrences);
  }
  
  async discoverRelatedContent(tags: string[]): Promise<ContentRecommendation[]> {
    const recommendations: ContentRecommendation[] = [];
    
    // Find documents with similar tag patterns
    const relatedTags = this.findRelatedTags(tags);
    
    for (const relatedTag of relatedTags) {
      const docs = await this.findDocumentsByTag(relatedTag.tag);
      
      docs.forEach(doc => {
        const similarity = this.calculateTagSimilarity(tags, doc.tags || []);
        if (similarity > 0.3) { // Threshold for relevance
          recommendations.push({
            document: doc,
            reason: `Related via tags: ${this.getCommonTags(tags, doc.tags || []).join(', ')}`,
            strength: similarity * relatedTag.strength,
            type: 'tag-similarity'
          });
        }
      });
    }
    
    return recommendations
      .sort((a, b) => b.strength - a.strength)
      .slice(0, 10); // Top 10 recommendations
  }
  
  private findRelatedTags(tags: string[], depth: number = 2): TagRelation[] {
    const relatedTags = new Map<string, number>();
    
    // Direct relationships
    tags.forEach(tag => {
      const hierarchy = this.tagHierarchy.get(tag);
      if (hierarchy) {
        hierarchy.relatedTags.forEach(relation => {
          const currentStrength = relatedTags.get(relation.tag) || 0;
          relatedTags.set(relation.tag, Math.max(currentStrength, relation.strength));
        });
      }
    });
    
    // Secondary relationships (if depth > 1)
    if (depth > 1) {
      const primaryRelated = Array.from(relatedTags.keys());
      primaryRelated.forEach(relatedTag => {
        const secondaryRelated = this.findRelatedTags([relatedTag], depth - 1);
        secondaryRelated.forEach(secondary => {
          const discountedStrength = secondary.strength * 0.5; // Discount for indirect relation
          const currentStrength = relatedTags.get(secondary.tag) || 0;
          relatedTags.set(secondary.tag, Math.max(currentStrength, discountedStrength));
        });
      });
    }
    
    return Array.from(relatedTags.entries())
      .map(([tag, strength]) => ({ tag, strength, type: 'related' as const }))
      .filter(relation => !tags.includes(relation.tag)) // Exclude original tags
      .sort((a, b) => b.strength - a.strength);
  }
}
```

### Full-Text Search Engine:
```typescript
interface SearchIndex {
  documentId: string;
  content: string;
  tokens: SearchToken[];
  stemmed: string[];
  metadata: IndexMetadata;
}

interface SearchToken {
  term: string;
  position: number;
  field: 'title' | 'content' | 'metadata';
  weight: number;
}

class FullTextSearchEngine {
  private index: Map<string, SearchIndex> = new Map();
  private invertedIndex: Map<string, PostingList> = new Map();
  private stemmer: Stemmer;
  private stopWords: Set<string>;
  
  constructor() {
    this.stemmer = new Stemmer();
    this.stopWords = new Set([
      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
      'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
      'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should'
    ]);
  }
  
  async indexDocument(document: Document): Promise<void> {
    // Tokenize content
    const tokens = this.tokenizeDocument(document);
    
    // Create search index entry
    const searchIndex: SearchIndex = {
      documentId: document.id,
      content: document.content,
      tokens,
      stemmed: tokens.map(token => this.stemmer.stem(token.term)),
      metadata: {
        wordCount: tokens.length,
        uniqueTerms: new Set(tokens.map(t => t.term)).size,
        averageTermLength: this.calculateAverageTermLength(tokens),
        lastIndexed: new Date()
      }
    };
    
    this.index.set(document.id, searchIndex);
    
    // Update inverted index
    await this.updateInvertedIndex(document.id, tokens);
  }
  
  private tokenizeDocument(document: Document): SearchToken[] {
    const tokens: SearchToken[] = [];
    let position = 0;
    
    // Tokenize title (higher weight)
    const titleTokens = this.tokenizeText(document.title, 'title', 3.0);
    titleTokens.forEach(token => {
      tokens.push({ ...token, position: position++ });
    });
    
    // Tokenize content
    const contentTokens = this.tokenizeText(document.content, 'content', 1.0);
    contentTokens.forEach(token => {
      tokens.push({ ...token, position: position++ });
    });
    
    // Tokenize metadata
    if (document.tags) {
      document.tags.forEach(tag => {
        const tagTokens = this.tokenizeText(tag, 'metadata', 2.0);
        tagTokens.forEach(token => {
          tokens.push({ ...token, position: position++ });
        });
      });
    }
    
    return tokens.filter(token => !this.stopWords.has(token.term.toLowerCase()));
  }
  
  private tokenizeText(text: string, field: SearchToken['field'], weight: number): Omit<SearchToken, 'position'>[] {
    // Simple tokenization - split on whitespace and punctuation
    const terms = text
      .toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(term => term.length > 2);
    
    return terms.map(term => ({
      term,
      field,
      weight
    }));
  }
  
  async search(query: string, options: SearchOptions = {}): Promise<SearchResult[]> {
    // Parse search query
    const queryTerms = this.parseSearchQuery(query);
    
    // Find candidate documents
    const candidates = await this.findCandidateDocuments(queryTerms);
    
    // Score and rank results
    const scoredResults = this.scoreDocuments(candidates, queryTerms);
    
    // Apply options and return
    return this.formatResults(scoredResults, options);
  }
  
  private scoreDocuments(candidates: Set<string>, queryTerms: string[]): ScoredResult[] {
    const results: ScoredResult[] = [];
    
    candidates.forEach(docId => {
      const searchIndex = this.index.get(docId);
      if (!searchIndex) return;
      
      let score = 0;
      const matchedTerms: string[] = [];
      
      queryTerms.forEach(queryTerm => {
        const matches = searchIndex.tokens.filter(token => 
          token.term.includes(queryTerm) || 
          this.stemmer.stem(token.term) === this.stemmer.stem(queryTerm)
        );
        
        if (matches.length > 0) {
          matchedTerms.push(queryTerm);
          
          // TF-IDF scoring
          const tf = matches.length / searchIndex.tokens.length;
          const idf = Math.log(this.index.size / this.getDocumentFrequency(queryTerm));
          const termScore = tf * idf;
          
          // Apply field weights
          const weightedScore = matches.reduce((sum, match) => sum + match.weight, 0) * termScore;
          score += weightedScore;
        }
      });
      
      if (score > 0) {
        results.push({
          documentId: docId,
          score,
          matchedTerms,
          totalMatches: matchedTerms.length
        });
      }
    });
    
    return results.sort((a, b) => b.score - a.score);
  }
}
```

### Relevance Ranking System:
```typescript
interface RankingFactors {
  textRelevance: number;      // 0-1 based on query match
  recency: number;            // 0-1 based on document age
  quality: number;            // 0-1 based on confidence scores
  userPreference: number;     // 0-1 based on user history
  documentType: number;       // 0-1 based on type relevance
  authorityScore: number;     // 0-1 based on source quality
}

class RelevanceRanker {
  private userPreferences: Map<string, UserSearchPreferences> = new Map();
  
  async rankResults(results: SearchResult[], query: ParsedSearchQuery): Promise<SearchResult[]> {
    const rankedResults = await Promise.all(
      results.map(async result => ({
        ...result,
        score: await this.calculateRelevanceScore(result, query),
        rankingFactors: await this.analyzeRankingFactors(result, query)
      }))
    );
    
    return rankedResults.sort((a, b) => b.score - a.score);
  }
  
  private async calculateRelevanceScore(result: SearchResult, query: ParsedSearchQuery): Promise<number> {
    const factors = await this.analyzeRankingFactors(result, query);
    
    // Weighted combination of ranking factors
    const weights = {
      textRelevance: 0.35,
      recency: 0.15,
      quality: 0.20,
      userPreference: 0.15,
      documentType: 0.10,
      authorityScore: 0.05
    };
    
    let totalScore = 0;
    Object.entries(weights).forEach(([factor, weight]) => {
      totalScore += factors[factor as keyof RankingFactors] * weight;
    });
    
    return Math.max(0, Math.min(1, totalScore));
  }
  
  private async analyzeRankingFactors(result: SearchResult, query: ParsedSearchQuery): Promise<RankingFactors> {
    const document = result.document;
    
    return {
      textRelevance: this.calculateTextRelevance(result, query),
      recency: this.calculateRecencyScore(document.createdAt),
      quality: this.calculateQualityScore(document),
      userPreference: await this.calculateUserPreferenceScore(document, query.userId),
      documentType: this.calculateDocumentTypeScore(document.type, query),
      authorityScore: this.calculateAuthorityScore(document)
    };
  }
  
  private calculateTextRelevance(result: SearchResult, query: ParsedSearchQuery): number {
    // Base score from search engine
    let relevance = result.score;
    
    // Boost for exact phrase matches
    if (query.text && result.document.content.includes(query.text)) {
      relevance *= 1.5;
    }
    
    // Boost for title matches
    if (query.text && result.document.title.toLowerCase().includes(query.text.toLowerCase())) {
      relevance *= 2.0;
    }
    
    // Normalize to 0-1 range
    return Math.min(1, relevance);
  }
  
  private calculateRecencyScore(createdAt: Date): number {
    const now = new Date();
    const ageInDays = (now.getTime() - createdAt.getTime()) / (1000 * 60 * 60 * 24);
    
    // Exponential decay with half-life of 30 days
    return Math.exp(-ageInDays / 43.2); // ln(2)/30 â‰ˆ 0.0231
  }
  
  private calculateQualityScore(document: Document): number {
    if (document.metadata?.confidence?.overall) {
      return document.metadata.confidence.overall;
    }
    
    // Fallback quality indicators
    let quality = 0.5; // Default medium quality
    
    // Boost for documents with sources
    if (document.sources && document.sources.length > 0) {
      quality += 0.2;
    }
    
    // Boost for longer, more detailed documents
    const wordCount = document.content.split(/\s+/).length;
    if (wordCount > 500) quality += 0.1;
    if (wordCount > 1000) quality += 0.1;
    
    // Boost for documents with methodologies
    if (document.methodologies && document.methodologies.length > 0) {
      quality += 0.1;
    }
    
    return Math.min(1, quality);
  }
  
  private async calculateUserPreferenceScore(document: Document, userId?: string): Promise<number> {
    if (!userId) return 0.5; // Neutral score for anonymous users
    
    const preferences = this.userPreferences.get(userId);
    if (!preferences) return 0.5;
    
    let score = 0.5;
    
    // Boost for preferred agents
    if (preferences.preferredAgents.includes(document.createdBy)) {
      score += 0.2;
    }
    
    // Boost for preferred document types
    if (preferences.preferredTypes.includes(document.type)) {
      score += 0.15;
    }
    
    // Boost for preferred tags
    const commonTags = (document.tags || []).filter(tag => 
      preferences.preferredTags.includes(tag)
    );
    score += commonTags.length * 0.05;
    
    return Math.min(1, score);
  }
}
```

### Testing
**Testing Framework:** Jest
**Test File Location:** `.flcm-core/tests/obsidian/search/`

**Unit Tests:**
- Search query parsing and validation
- Metadata filtering accuracy
- Tag-based discovery algorithms
- Full-text search indexing and retrieval
- Relevance ranking calculations
- Date range filtering logic

**Integration Tests:**
- End-to-end search workflow
- Multi-provider search coordination
- Search result consistency
- Performance with large document sets
- User preference learning
- Search analytics and tracking

**Performance Tests:**
- Search response time benchmarks
- Index building performance
- Memory usage optimization
- Concurrent search handling
- Large vault scalability

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_