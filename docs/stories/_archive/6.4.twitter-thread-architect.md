# Story 6.4: X/Twitter Thread Architect

## Status
Approved

## Story
**As a** user,  
**I want** content structured as Twitter threads,  
**so that** complex ideas spread virally.

**Estimated Time:** 4-5 hours

## Acceptance Criteria
1. Thread breaking algorithm
2. Hook tweet optimization
3. Thread flow management
4. Engagement point insertion
5. Hashtag strategy
6. Reply thread preparation

## Tasks / Subtasks
- [ ] Implement thread breaking algorithm (AC: 1)
  - [ ] Create ThreadBreaker class
  - [ ] Split content into 280-char tweets
  - [ ] Preserve sentence integrity
  - [ ] Maintain logical flow
  - [ ] Handle code/links specially
  - [ ] Number tweets (1/n format)
- [ ] Optimize hook tweet (AC: 2)
  - [ ] Create HookGenerator class
  - [ ] Generate compelling first tweet
  - [ ] Test multiple hook styles
  - [ ] Include curiosity gap
  - [ ] Add visual elements (emojis)
  - [ ] Optimize for timeline stopping
- [ ] Manage thread flow (AC: 3)
  - [ ] Create ThreadFlowManager
  - [ ] Ensure narrative progression
  - [ ] Add cliffhangers between tweets
  - [ ] Maintain reading momentum
  - [ ] Create mini-sections
  - [ ] Add transition phrases
- [ ] Insert engagement points (AC: 4)
  - [ ] Identify engagement opportunities
  - [ ] Add questions mid-thread
  - [ ] Include "bookmark this" prompts
  - [ ] Create quote-tweet moments
  - [ ] Add reaction triggers
  - [ ] Include share incentives
- [ ] Implement hashtag strategy (AC: 5)
  - [ ] Select 1-3 relevant hashtags
  - [ ] Place strategically (not first tweet)
  - [ ] Mix trending and niche tags
  - [ ] Avoid over-tagging
  - [ ] Test hashtag performance
  - [ ] Create branded hashtags
- [ ] Prepare reply threads (AC: 6)
  - [ ] Generate FAQ responses
  - [ ] Create expansion tweets
  - [ ] Prepare clarifications
  - [ ] Add resource links
  - [ ] Build engagement responses
  - [ ] Plan follow-up content

## Dev Notes

### Twitter Thread Architecture:
```typescript
interface TwitterThread {
  tweets: Tweet[];
  hookTweet: Tweet;
  totalTweets: number;
  estimatedReadTime: number;
  viralScore: number;
  hashtags: string[];
  replyThreads: ReplyThread[];
}

interface Tweet {
  id: number;
  content: string;
  characterCount: number;
  hasMedia: boolean;
  engagementType?: 'question' | 'poll' | 'cta';
  position: 'hook' | 'body' | 'conclusion';
}

class TwitterThreadArchitect {
  async createThread(content: ContentDraft): Promise<TwitterThread> {
    // Break into tweets
    const tweets = await this.breakIntoTweets(content.content);
    
    // Optimize hook
    const hook = await this.createHookTweet(tweets[0], content);
    
    // Manage flow
    const flowOptimized = this.optimizeFlow(tweets);
    
    // Add engagement
    const engaging = this.insertEngagementPoints(flowOptimized);
    
    // Add hashtags
    const tagged = this.addHashtags(engaging);
    
    // Prepare replies
    const replies = this.prepareReplies(content);
    
    return {
      tweets: [hook, ...tagged],
      hookTweet: hook,
      totalTweets: tagged.length + 1,
      estimatedReadTime: (tagged.length * 15) / 60, // 15 sec per tweet
      viralScore: this.calculateViralScore(hook, tagged),
      engagementOptimization: this.analyzeEngagementPotential(tagged),
      hashtags: this.selectHashtags(content),
      replyThreads: replies
    };
  }
}
```

### Thread Breaking Algorithm:
```typescript
class ThreadBreaker {
  breakIntoTweets(content: string): Tweet[] {
    const tweets: Tweet[] = [];
    const sentences = this.splitIntoSentences(content);
    
    let currentTweet = '';
    let tweetCount = 0;
    
    for (const sentence of sentences) {
      // Check if sentence fits in current tweet
      if (this.fitsInTweet(currentTweet, sentence)) {
        currentTweet += ' ' + sentence;
      } else {
        // Save current tweet
        if (currentTweet) {
          tweets.push(this.createTweet(currentTweet, ++tweetCount));
        }
        
        // Start new tweet
        if (sentence.length > 280) {
          // Break long sentence
          tweets.push(...this.breakLongSentence(sentence, tweetCount));
        } else {
          currentTweet = sentence;
        }
      }
    }
    
    // Add final tweet
    if (currentTweet) {
      tweets.push(this.createTweet(currentTweet, ++tweetCount));
    }
    
    // Add numbering
    return this.addNumbering(tweets);
  }
  
  private fitsInTweet(current: string, addition: string): boolean {
    // Account for numbering (e.g., "12/25 ")
    const numberingLength = 6;
    return (current.length + addition.length + numberingLength) <= 280;
  }
  
  private addNumbering(tweets: Tweet[]): Tweet[] {
    const total = tweets.length;
    return tweets.map((tweet, index) => ({
      ...tweet,
      content: `${index + 1}/${total} ${tweet.content}`
    }));
  }
}
```

### Hook Tweet Optimization:
```typescript
class HookGenerator {
  generateHook(content: string, style: HookStyle): Tweet {
    const hooks = {
      'controversial': this.generateControversial(content),
      'question': this.generateQuestion(content),
      'statistic': this.generateStatistic(content),
      'story': this.generateStory(content),
      'list': this.generateList(content),
      'challenge': this.generateChallenge(content)
    };
    
    // Test multiple styles and select best
    const candidates = Object.values(hooks);
    return this.selectBestHook(candidates);
  }
  
  private generateControversial(content: string): string {
    const templates = [
      "Unpopular opinion: [controversial take] ðŸ”¥",
      "Everyone thinks [common belief]. They're wrong. Here's why:",
      "The [industry] doesn't want you to know this:",
      "[Common practice] is killing your [outcome]. Time for truth:"
    ];
    
    return this.fillTemplate(templates, content);
  }
  
  private generateQuestion(content: string): string {
    const templates = [
      "Ever wonder why [phenomenon]? ðŸ¤”",
      "What if I told you [surprising fact]?",
      "Why does [problem] keep happening?",
      "How do [successful people] actually [achieve outcome]?"
    ];
    
    return this.fillTemplate(templates, content);
  }
  
  private generateStatistic(content: string): string {
    const templates = [
      "93% of [group] fail at [task]. Here's what the 7% know:",
      "[Number]x increase in [metric] with one simple change:",
      "After analyzing [large number] [items], I found something shocking:",
      "New research: [surprising percentage] of [thing] is wrong"
    ];
    
    return this.fillTemplate(templates, content);
  }
}
```

### Thread Flow Management:
```typescript
class ThreadFlowManager {
  optimizeFlow(tweets: Tweet[]): Tweet[] {
    const optimized: Tweet[] = [];
    
    for (let i = 0; i < tweets.length; i++) {
      let tweet = tweets[i];
      
      // Add cliffhangers
      if (this.shouldAddCliffhanger(i, tweets.length)) {
        tweet = this.addCliffhanger(tweet);
      }
      
      // Add transitions
      if (this.needsTransition(i, tweets)) {
        tweet = this.addTransition(tweet, tweets[i-1]);
      }
      
      // Create mini-sections
      if (this.isNewSection(i, tweets)) {
        tweet = this.markNewSection(tweet);
      }
      
      optimized.push(tweet);
    }
    
    return optimized;
  }
  
  private addCliffhanger(tweet: Tweet): Tweet {
    const cliffhangers = [
      "But here's where it gets interesting...",
      "What happened next changed everything:",
      "The real secret?",
      "This is crucial:",
      "Pay attention to this part:"
    ];
    
    // Add to end of tweet if space
    return this.appendIfSpace(tweet, cliffhangers);
  }
  
  private addTransition(tweet: Tweet, previous: Tweet): Tweet {
    const transitions = [
      "Here's the thing:",
      "But wait:",
      "Even better:",
      "The result?",
      "Now, consider this:"
    ];
    
    return this.prependIfSpace(tweet, transitions);
  }
}
```

### Engagement Point Insertion:
```typescript
class EngagementInserter {
  insertEngagementPoints(tweets: Tweet[]): Tweet[] {
    const withEngagement = [...tweets];
    
    // Add question at 1/3 point
    const questionPoint = Math.floor(tweets.length / 3);
    withEngagement[questionPoint] = this.addQuestion(tweets[questionPoint]);
    
    // Add bookmark prompt at valuable insight
    const insightPoint = this.findBestInsight(tweets);
    withEngagement[insightPoint] = this.addBookmarkPrompt(tweets[insightPoint]);
    
    // Add quote prompt for tweetable moment
    const quotablePoint = this.findQuotable(tweets);
    withEngagement[quotablePoint] = this.makeQuotable(tweets[quotablePoint]);
    
    // Add CTA in final tweet
    const lastIndex = tweets.length - 1;
    withEngagement[lastIndex] = this.addCTA(tweets[lastIndex]);
    
    return withEngagement;
  }
  
  private addQuestion(tweet: Tweet): Tweet {
    const questions = [
      "What's your experience with this?",
      "Have you seen this pattern?",
      "Agree or disagree?",
      "What would you add?"
    ];
    
    return this.appendEngagement(tweet, questions, 'question');
  }
  
  private addBookmarkPrompt(tweet: Tweet): Tweet {
    return {
      ...tweet,
      content: `ðŸ“Œ ${tweet.content}` // Bookmark emoji signals value
    };
  }
}
```

### Hashtag Strategy:
```typescript
class TwitterHashtagStrategy {
  selectHashtags(content: ContentDraft): string[] {
    const allHashtags = this.extractPotentialHashtags(content);
    
    // Score hashtags
    const scored = allHashtags.map(tag => ({
      tag,
      score: this.scoreHashtag(tag)
    }));
    
    // Select top 2-3
    const selected = scored
      .sort((a, b) => b.score - a.score)
      .slice(0, 3)
      .map(s => s.tag);
    
    return this.optimizePlacement(selected);
  }
  
  private scoreHashtag(tag: string): number {
    let score = 0;
    
    // Trending bonus
    if (this.isTrending(tag)) score += 3;
    
    // Relevance score
    score += this.calculateRelevance(tag);
    
    // Competition penalty
    if (this.isOverSaturated(tag)) score -= 2;
    
    // Length preference (shorter is better)
    if (tag.length < 15) score += 1;
    
    return score;
  }
  
  private optimizePlacement(tags: string[]): string[] {
    // Never in first tweet (hurts reach)
    // Best in tweets 2-4
    // One per tweet max
    return tags;
  }
}
```

### Reply Thread Preparation:
```typescript
interface ReplyThread {
  trigger: string; // What question/comment triggers this
  responses: Tweet[];
  type: 'faq' | 'expansion' | 'resources' | 'clarification';
}

class ReplyThreadBuilder {
  prepareReplies(content: ContentDraft): ReplyThread[] {
    return [
      this.createFAQThread(content),
      this.createExpansionThread(content),
      this.createResourceThread(content),
      this.createClarificationThread(content)
    ];
  }
  
  private createFAQThread(content: ContentDraft): ReplyThread {
    return {
      trigger: 'questions',
      type: 'faq',
      responses: [
        { content: "Great question! Let me clarify:", ... },
        { content: "The main point is:", ... },
        { content: "Think of it this way:", ... }
      ]
    };
  }
  
  private createExpansionThread(content: ContentDraft): ReplyThread {
    return {
      trigger: 'tell me more',
      type: 'expansion',
      responses: [
        { content: "Let me go deeper on this:", ... },
        { content: "Here's a specific example:", ... },
        { content: "The advanced version:", ... }
      ]
    };
  }
}
```

### Viral Score Calculation:
```typescript
interface ViralMetrics {
  hookScore: number;        // 0-40 points
  engagementScore: number;  // 0-30 points
  contentScore: number;     // 0-20 points
  structureScore: number;   // 0-10 points
  total: number;           // 0-100
  likelihood: 'low' | 'medium' | 'high' | 'viral';
}

class ViralScoreCalculator {
  calculateViralScore(hook: Tweet, tweets: Tweet[]): ViralMetrics {
    const hookScore = this.scoreHook(hook);
    const engagementScore = this.scoreEngagement(tweets);
    const contentScore = this.scoreContent(tweets);
    const structureScore = this.scoreStructure(tweets);
    
    const total = hookScore + engagementScore + contentScore + structureScore;
    
    return {
      hookScore,
      engagementScore,
      contentScore,
      structureScore,
      total,
      likelihood: this.calculateLikelihood(total)
    };
  }
  
  private scoreHook(hook: Tweet): number {
    let score = 0;
    const content = hook.content.toLowerCase();
    
    // Controversy/Bold claims (15 points)
    const controversialMarkers = ['unpopular opinion', 'everyone thinks', "they're wrong"];
    if (controversialMarkers.some(marker => content.includes(marker))) score += 15;
    
    // Curiosity gaps (10 points)
    const curiosityGaps = ['here\'s why', 'what i found', 'the secret', 'surprising'];
    if (curiosityGaps.some(gap => content.includes(gap))) score += 10;
    
    // Statistics/Numbers (8 points)
    if (/\d+%|\d+x|\d+ (people|companies)/.test(content)) score += 8;
    
    // Emotional triggers (7 points)
    const emotions = ['shocking', 'amazing', 'unbelievable', 'game-changer'];
    if (emotions.some(emotion => content.includes(emotion))) score += 7;
    
    return Math.min(40, score);
  }
  
  private scoreEngagement(tweets: Tweet[]): number {
    let score = 0;
    let questionCount = 0;
    let ctaCount = 0;
    
    for (const tweet of tweets) {
      // Questions increase engagement
      if (tweet.content.includes('?')) questionCount++;
      
      // Call-to-actions
      if (['RT', 'share', 'bookmark', 'follow'].some(cta => 
        tweet.content.toLowerCase().includes(cta))) ctaCount++;
      
      // Engagement hooks
      if (tweet.engagementType) score += 5;
    }
    
    // Question distribution (10 points)
    if (questionCount >= 2 && questionCount <= 4) score += 10;
    
    // CTA presence (10 points)
    if (ctaCount >= 2) score += 10;
    
    // Thread ending engagement (10 points)
    const lastTweet = tweets[tweets.length - 1];
    if (this.hasEngagingEnding(lastTweet)) score += 10;
    
    return Math.min(30, score);
  }
  
  private scoreContent(tweets: Tweet[]): number {
    let score = 0;
    const totalContent = tweets.map(t => t.content).join(' ');
    
    // Actionable advice (8 points)
    if (/step \d|how to|tip:|strategy:|method:/.test(totalContent.toLowerCase())) score += 8;
    
    // Stories/Examples (6 points)
    if (/example|story|case study|experience/.test(totalContent.toLowerCase())) score += 6;
    
    // Value density (6 points)
    const valueWords = ['learn', 'discover', 'understand', 'improve', 'better'];
    const valueCount = valueWords.filter(word => 
      totalContent.toLowerCase().includes(word)).length;
    score += Math.min(6, valueCount * 2);
    
    return Math.min(20, score);
  }
  
  private scoreStructure(tweets: Tweet[]): number {
    let score = 0;
    
    // Optimal length (3-15 tweets) (3 points)
    if (tweets.length >= 3 && tweets.length <= 15) score += 3;
    
    // Good pacing (no tweets over 250 chars) (3 points)
    if (tweets.every(t => t.characterCount <= 250)) score += 3;
    
    // Visual elements (emojis, bullets) (2 points)
    if (tweets.some(t => /[ðŸ“ŒðŸŽ¯ðŸ’¡â­ï¸ðŸ”¥ðŸš€]/.test(t.content))) score += 2;
    
    // Progressive revelation (2 points)
    if (this.hasProgressiveStructure(tweets)) score += 2;
    
    return Math.min(10, score);
  }
  
  private calculateLikelihood(score: number): string {
    if (score >= 80) return 'viral';
    if (score >= 60) return 'high';
    if (score >= 40) return 'medium';
    return 'low';
  }
}

### Engagement Optimization:
```typescript
interface EngagementAnalysis {
  replyProbability: number;
  retweetProbability: number;
  likeProbability: number;
  bookmarkProbability: number;
  optimizations: string[];
}

class EngagementOptimizer {
  analyzeEngagementPotential(tweets: Tweet[]): EngagementAnalysis {
    const replyProb = this.calculateReplyProbability(tweets);
    const retweetProb = this.calculateRetweetProbability(tweets);
    const likeProb = this.calculateLikeProbability(tweets);
    const bookmarkProb = this.calculateBookmarkProbability(tweets);
    
    return {
      replyProbability: replyProb,
      retweetProbability: retweetProb,
      likeProbability: likeProb,
      bookmarkProbability: bookmarkProb,
      optimizations: this.generateOptimizations(tweets)
    };
  }
  
  private generateOptimizations(tweets: Tweet[]): string[] {
    const optimizations = [];
    
    // Check for engagement gaps
    const questionCount = tweets.filter(t => t.content.includes('?')).length;
    if (questionCount < 2) {
      optimizations.push("Add more questions to increase reply probability");
    }
    
    // Check for tweetable moments
    const quotableCount = tweets.filter(t => 
      this.isQuotable(t.content)).length;
    if (quotableCount < 1) {
      optimizations.push("Add quotable insights to increase retweet probability");
    }
    
    // Check for value signals
    if (!tweets.some(t => /ðŸ“Œ|ðŸ’¡|â­ï¸/.test(t.content))) {
      optimizations.push("Add bookmark indicators for high-value content");
    }
    
    return optimizations;
  }
}

### Viral Elements:
```typescript
const viralPatterns = {
  hooks: [
    "ðŸš¨ Breaking:",
    "Thread:",
    "A story:",
    "Let's talk about",
    "Time for some truth:"
  ],
  
  endings: [
    "If this helped, please RT the first tweet!",
    "That's it. That's the thread.",
    "Follow for more [topic] content",
    "What's your take?",
    "fin."
  ],
  
  engagement: [
    "RT if you agree",
    "Like if helpful",
    "Bookmark for later",
    "Share with someone who needs this"
  ]
};
```

### Testing
**Testing Framework:** Jest
**Test File Location:** `.flcm-core/tests/adapter/`

**Unit Tests:**
- Thread breaking accuracy (sentence preservation, logical flow)
- Character count compliance (280 char limit, numbering space)
- Hook effectiveness scoring (viral patterns, curiosity gaps)
- Flow optimization (cliffhangers, transitions)
- Hashtag selection and placement strategy
- Viral score calculation accuracy
- Engagement probability predictions

**Edge Case Tests:**
- Very long sentences (>280 characters) breaking
- Content with code blocks and special formatting
- URLs and mentions character counting
- Thread numbering with 3+ digit counts (100+)
- Emoji handling in character limits
- Multi-language content support
- Content with excessive punctuation/special characters

**Test Content:**
```
tests/fixtures/twitter/
â”œâ”€â”€ long-content.md
â”œâ”€â”€ technical-explanation.md
â”œâ”€â”€ story-format.md
â”œâ”€â”€ list-content.md
â”œâ”€â”€ edge-cases/
â”‚   â”œâ”€â”€ very-long-sentences.md
â”‚   â”œâ”€â”€ code-heavy-content.md
â”‚   â”œâ”€â”€ url-rich-content.md
â”‚   â””â”€â”€ emoji-heavy-content.md
â””â”€â”€ viral-examples/
    â”œâ”€â”€ high-performing-threads.md
    â””â”€â”€ failed-threads.md
```

**Integration Tests:**
- Full thread generation pipeline (content â†’ Twitter thread)
- Engagement optimization effectiveness measurement
- Viral score calculation validation against real data
- Reply thread creation and relevance scoring
- End-to-end character limit compliance
- Multi-format content adaptation accuracy
- Performance testing for thread generation speed

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-28 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_